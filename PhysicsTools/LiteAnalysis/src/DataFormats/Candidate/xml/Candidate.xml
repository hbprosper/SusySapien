<?xml version="1.0"?>
<!--
==============================================================================
  XML File: Candidate.xml
  Created:  Thu Jan 14 22:46:38 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Candidate/interface/Candidate.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Candidate/interface/Candidate.h">

    <include name="&quot;DataFormats/Candidate/interface/Particle.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/component.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/const_iterator.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/iterator.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/CandidateFwd.h&quot;"/>
    <include name="&quot;DataFormats/Math/interface/Error.h&quot;"/>
    <include name="&quot;boost/iterator/filter_iterator.hpp&quot;"/>
    <forward name="OverlapChecker"/>

    <namespace name="reco">

        <class name="Candidate"
               fullname="reco::Candidate"
               module="DataFormats.Candidate"
               project=""
               type="abstract regular">
            <baseclass name="public Particle"/>

            <section name="public">
                <typedef name="size_type"
                         value="size_t">
typedef size_t size_type;
                    <comment>
        size type
                    </comment>
                </typedef>

                <typedef name="const_iterator"
                         value="candidate::const_iterator">
typedef candidate::const_iterator const_iterator;
                </typedef>

                <typedef name="iterator"
                         value="candidate::iterator">
typedef candidate::iterator iterator;
                </typedef>

                <enum name="">
enum {
 dimension=3 };
                    <field name="dimension" value="3"/>
                    <comment>
        error matrix dimension
                    </comment>
                </enum>

                <typedef name="CovarianceMatrix"
                         value="math::Error&lt;dimension&gt;::type">
typedef math::Error&lt;dimension&gt;::type CovarianceMatrix;
                    <comment>
        covariance error matrix (3x3)
                    </comment>
                </typedef>

                <enum name="">
enum {
 size=dimension* (dimension+1)/2 };
                    <field name="size" value="dimension* (dimension+1)/2"/>
                    <comment>
        matix size
                    </comment>
                </enum>

                <typedef name="index"
                         value="unsigned int">
typedef unsigned int index;
                    <comment>
        index type
                    </comment>
                </typedef>

                <constructor name="Candidate"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
Candidate();
                    <comment>
        default constructor
                    </comment>
                </constructor>

                <constructor name="Candidate"
                             return="explicit"
                             args="['const Particle&amp;']"
                             vars="['p']"
                             qual="">
explicit Candidate(const Particle&amp; p);
                    <comment>
        constructor from a Particle
                    </comment>
                </constructor>

                <constructor name="Candidate"
                             return=""
                             args="['Charge','const LorentzVector&amp;','const Point&amp;=Point(0, 0, 0)','int=0','int=0','bool=true']"
                             vars="['q','p4','vtx','pdgId','status','integerCharge']"
                             qual="">
Candidate(Charge q, const LorentzVector&amp; p4, const Point&amp; vtx=Point(0, 0, 0), int pdgId=0, int status=0, bool integerCharge=true);
                    <comment>
        constructor from values
                    </comment>
                </constructor>

                <constructor name="Candidate"
                             return=""
                             args="['Charge','const PolarLorentzVector&amp;','const Point&amp;=Point(0, 0, 0)','int=0','int=0','bool=true']"
                             vars="['q','p4','vtx','pdgId','status','integerCharge']"
                             qual="">
Candidate(Charge q, const PolarLorentzVector&amp; p4, const Point&amp; vtx=Point(0, 0, 0), int pdgId=0, int status=0, bool integerCharge=true);
                    <comment>
        constructor from values
                    </comment>
                </constructor>

                <destructor name="~Candidate"
                            return="virtual"
                            args="['void']"
                            vars="['']"
                            qual="">
virtual ~Candidate();
                    <comment>
        destructor
                    </comment>
                </destructor>

                <method1 name="clone"
                         return="virtual Candidate*"
                         args="['void']"
                         vars="['']"
                         qual="const = 0">
virtual Candidate* clone() const=0;
                    <comment>
        returns a clone of the Candidate object
                    </comment>
                </method1>

                <method1 name="begin"
                         return="virtual const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const = 0">
virtual const_iterator begin() const=0;
                    <comment>
        first daughter const_iterator
                    </comment>
                </method1>

                <method1 name="end"
                         return="virtual const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const = 0">
virtual const_iterator end() const=0;
                    <comment>
        last daughter const_iterator
                    </comment>
                </method1>

                <method1 name="begin"
                         return="virtual iterator"
                         args="['void']"
                         vars="['']"
                         qual="= 0">
virtual iterator begin()=0;
                    <comment>
        first daughter iterator
                    </comment>
                </method1>

                <method1 name="end"
                         return="virtual iterator"
                         args="['void']"
                         vars="['']"
                         qual="= 0">
virtual iterator end()=0;
                    <comment>
        last daughter iterator
                    </comment>
                </method1>

                <method1 name="numberOfDaughters"
                         return="virtual size_type"
                         args="['void']"
                         vars="['']"
                         qual="const = 0">
virtual size_type numberOfDaughters() const=0;
                    <comment>
        number of daughters
                    </comment>
                </method1>

                <method1 name="daughter"
                         return="virtual const Candidate*"
                         args="['size_type']"
                         vars="['i']"
                         qual="const = 0">
virtual const Candidate* daughter(size_type i) const=0;
                    <comment>
        return daughter at a given position, i = 0, ... numberOfDaughters() - 1 (read only mode)
                    </comment>
                </method1>

                <method1 name="daughter"
                         return="virtual Candidate*"
                         args="['size_type']"
                         vars="['i']"
                         qual="= 0">
virtual Candidate* daughter(size_type i)=0;
                    <comment>
        return daughter at a given position, i = 0, ... numberOfDaughters() - 1
                    </comment>
                </method1>

                <method1 name="daughter"
                         return="virtual Candidate*"
                         args="['const std::string&amp;']"
                         vars="['s']"
                         qual="">
virtual Candidate* daughter(const std::string&amp; s);
                    <comment>
        return daughter with a specified role name
                    </comment>
                </method1>

                <method1 name="daughter"
                         return="virtual const Candidate*"
                         args="['const std::string&amp;']"
                         vars="['s']"
                         qual="const">
virtual const Candidate* daughter(const std::string&amp; s) const;
                    <comment>
        return daughter with a specified role name
                    </comment>
                </method1>

                <method1 name="numberOfMothers"
                         return="virtual size_type"
                         args="['void']"
                         vars="['']"
                         qual="const = 0">
virtual size_type numberOfMothers() const=0;
                    <comment>
        number of mothers (zero or one in most of but not all the cases)
                    </comment>
                </method1>

                <method1 name="mother"
                         return="virtual const Candidate*"
                         args="['size_type=0']"
                         vars="['i']"
                         qual="const = 0">
virtual const Candidate* mother(size_type i=0) const=0;
                    <comment>
        return pointer to mother
                    </comment>
                </method1>

                <method1 name="numberOfSourceCandidatePtrs"
                         return="virtual size_t"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual size_t numberOfSourceCandidatePtrs() const;
                    <comment>
        ( the candidates used to construct this Candidate)
                    </comment>
                </method1>

                <method1 name="sourceCandidatePtr"
                         return="virtual CandidatePtr"
                         args="['size_type']"
                         vars="['i']"
                         qual="const">
virtual CandidatePtr sourceCandidatePtr(size_type i) const;
                    <comment>
        ( the candidates used to construct this Candidate)
                    </comment>
                </method1>

                <method1 name="vertexChi2"
                         return="virtual double"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual double vertexChi2() const;
                    <comment>
        chi-squares
                    </comment>
                </method1>

                <method1 name="vertexNdof"
                         return="virtual double"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual double vertexNdof() const;
                    <comment>
        Number of degrees of freedom
        Meant to be Double32_t for soft-assignment fitters:
        tracks may contribute to the vertex with fractional weights.
        The ndof is then = to the sum of the track weights.
        see e.g. CMS NOTE-2006/032, CMS NOTE-2004/002
                    </comment>
                </method1>

                <method1 name="vertexNormalizedChi2"
                         return="virtual double"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual double vertexNormalizedChi2() const;
                    <comment>
        chi-squared divided by n.d.o.f.
                    </comment>
                </method1>

                <method1 name="vertexCovariance"
                         return="virtual double"
                         args="['int','int']"
                         vars="['i','j']"
                         qual="const">
virtual double vertexCovariance(int i, int j) const;
                    <comment>
        (i, j)-th element of error matrix, i, j = 0, ... 2
                    </comment>
                </method1>

                <method1 name="vertexCovariance"
                         return="CovarianceMatrix"
                         args="['void']"
                         vars="['']"
                         qual="const">
CovarianceMatrix vertexCovariance() const;
                    <comment>
        return SMatrix
                    </comment>
                </method1>

                <method1 name="fillVertexCovariance"
                         return="virtual void"
                         args="['CovarianceMatrix&amp;']"
                         vars="['v']"
                         qual="const">
virtual void fillVertexCovariance(CovarianceMatrix&amp; v) const;
                    <comment>
        fill SMatrix
                    </comment>
                </method1>

                <method1 name="hasMasterClone"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool hasMasterClone() const;
                    <comment>
        This only happens if the concrete Candidate type is ShallowCloneCandidate
                    </comment>
                </method1>

                <method1 name="masterClone"
                         return="virtual const CandidateBaseRef&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual const CandidateBaseRef&amp; masterClone() const;
                    <comment>
        Throws an exception unless the concrete Candidate type is ShallowCloneCandidate
                    </comment>
                </method1>

                <method1 name="hasMasterClonePtr"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool hasMasterClonePtr() const;
                    <comment>
        This only happens if the concrete Candidate type is ShallowClonePtrCandidate
                    </comment>
                </method1>

                <method1 name="masterClonePtr"
                         return="virtual const CandidatePtr&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual const CandidatePtr&amp; masterClonePtr() const;
                    <comment>
        Throws an exception unless the concrete Candidate type is ShallowClonePtrCandidate
                    </comment>
                </method1>

                <method2 name="masterRef"
                         return="template&lt;typename Ref&gt; Ref"
                         args="['void']"
                         vars="['']"
                         qual="const">
template&lt;typename Ref&gt;     Ref masterRef() const;
                    <comment>
        cast master clone reference to a concrete type
                    </comment>
                </method2>

                <method2 name="get"
                         return="template&lt;typename T&gt; T"
                         args="['void']"
                         vars="['']"
                         qual="const">
template&lt;typename T&gt; T get() const;
                    <comment>
        get a component
                    </comment>
                </method2>

                <method2 name="get"
                         return="template&lt;typename T, typename Tag&gt; T"
                         args="['void']"
                         vars="['']"
                         qual="const">
template&lt;typename T, typename Tag&gt; T get() const;
                    <comment>
        get a component
                    </comment>
                </method2>

                <method2 name="get"
                         return="template&lt;typename T&gt; T"
                         args="['size_type']"
                         vars="['i']"
                         qual="const">
template&lt;typename T&gt; T get(size_type i) const;
                    <comment>
        get a component
                    </comment>
                </method2>

                <method2 name="get"
                         return="template&lt;typename T, typename Tag&gt; T"
                         args="['size_type']"
                         vars="['i']"
                         qual="const">
template&lt;typename T, typename Tag&gt; T get(size_type i) const;
                    <comment>
        get a component
                    </comment>
                </method2>

                <method2 name="numberOf"
                         return="template&lt;typename T&gt; size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
template&lt;typename T&gt; size_type numberOf() const;
                    <comment>
        number of components
                    </comment>
                </method2>

                <method2 name="numberOf"
                         return="template&lt;typename T, typename Tag&gt; size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
template&lt;typename T, typename Tag&gt; size_type numberOf() const;
                    <comment>
        number of components
                    </comment>
                </method2>


                <class name="daughter_iterator"
                       fullname="reco::Candidate::daughter_iterator&lt;S&gt;"
                       module="DataFormats.Candidate"
                       project=""
                       type="template struct"
                       template="template&lt;typename S&gt;">

                    <section>
                        <typedef name="type"
                                 value="boost::filter_iterator&lt;S, const_iterator&gt;">
typedef boost::filter_iterator&lt;S, const_iterator&gt; type;
                        </typedef>

                    </section>

                    <typemap name="daughter_iterator"
                             value="reco::Candidate::daughter_iterator&lt;S&gt;"
                             type="class"/>
                    <typemap name="type"
                             value="boost::filter_iterator&lt;S, const_iterator&gt;"
                             type="typedef"/>

                </class>
                <method2 name="beginFilter"
                         return="template&lt;typename S&gt; typename daughter_iterator&lt;S&gt;::type"
                         args="['const S&amp;']"
                         vars="['s']"
                         qual="const">
template&lt;typename S&gt;     typename daughter_iterator&lt;S&gt;::type beginFilter(const S&amp; s) const;
                </method2>

                <method2 name="endFilter"
                         return="template&lt;typename S&gt; typename daughter_iterator&lt;S&gt;::type"
                         args="['const S&amp;']"
                         vars="['s']"
                         qual="const">
template&lt;typename S&gt;     typename daughter_iterator&lt;S&gt;::type endFilter(const S&amp; s) const;
                </method2>

                <method1 name="isElectron"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isElectron() const;
                </method1>

                <method1 name="isMuon"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isMuon() const;
                </method1>

                <method1 name="isStandAloneMuon"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isStandAloneMuon() const;
                </method1>

                <method1 name="isGlobalMuon"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isGlobalMuon() const;
                </method1>

                <method1 name="isTrackerMuon"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isTrackerMuon() const;
                </method1>

                <method1 name="isCaloMuon"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isCaloMuon() const;
                </method1>

                <method1 name="isPhoton"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isPhoton() const;
                </method1>

                <method1 name="isConvertedPhoton"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isConvertedPhoton() const;
                </method1>

                <method1 name="isJet"
                         return="virtual bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual bool isJet() const;
                </method1>

            </section>

            <typemap name="CovarianceMatrix"
                     value="math::Error&lt;dimension&gt;::type"
                     type="typedef"/>
            <typemap name="const_iterator"
                     value="candidate::const_iterator"
                     type="typedef"/>
            <typemap name="dimension "
                     value="reco::Candidate::dimension "
                     type="enum"/>
            <typemap name="index"
                     value="unsigned int"
                     type="typedef"/>
            <typemap name="iterator"
                     value="candidate::iterator"
                     type="typedef"/>
            <typemap name="size "
                     value="reco::Candidate::size "
                     type="enum"/>
            <typemap name="size_type"
                     value="size_t"
                     type="typedef"/>

        </class>
    </namespace>

    <type name="Candidate*"/>
    <type name="CandidatePtr"/>
    <type name="Charge"/>
    <type name="CovarianceMatrix"/>
    <type name="CovarianceMatrix&amp;"/>
    <type name="Particle"/>
    <type name="bool"/>
    <type name="const Candidate*"/>
    <type name="const CandidateBaseRef&amp;"/>
    <type name="const CandidatePtr&amp;"/>
    <type name="const LorentzVector&amp;"/>
    <type name="const Particle&amp;"/>
    <type name="const Point&amp;"/>
    <type name="const PolarLorentzVector&amp;"/>
    <type name="const std::string&amp;"/>
    <type name="const_iterator"/>
    <type name="double"/>
    <type name="enum"/>
    <type name="int"/>
    <type name="iterator"/>
    <type name="reco::Candidate"/>
    <type name="reco::Candidate::daughter_iterator&lt;S&gt;"/>
    <type name="size_t"/>
    <type name="size_type"/>
    <type name="template&lt;typename Ref&gt; Ref"/>
    <type name="template&lt;typename S&gt; typename daughter_iterator&lt;S&gt;::type"/>
    <type name="template&lt;typename T, typename Tag&gt; T"/>
    <type name="template&lt;typename T, typename Tag&gt; size_type"/>
    <type name="template&lt;typename T&gt; T"/>
    <type name="template&lt;typename T&gt; size_type"/>
    <type name="void"/>
</header>
