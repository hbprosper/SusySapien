<?xml version="1.0"?>
<!--
==============================================================================
  XML File: Muon.xml
  Created:  Thu Jan 14 22:47:43 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/MuonReco/interface/Muon.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/MuonReco/interface/Muon.h">

    <include name="&quot;DataFormats/RecoCandidate/interface/RecoCandidate.h&quot;"/>
    <include name="&quot;DataFormats/MuonReco/interface/MuonChamberMatch.h&quot;"/>
    <include name="&quot;DataFormats/MuonReco/interface/MuonIsolation.h&quot;"/>
    <include name="&quot;DataFormats/MuonReco/interface/MuonEnergy.h&quot;"/>
    <include name="&quot;DataFormats/MuonReco/interface/MuonTime.h&quot;"/>

    <namespace name="reco">

        <class name="Muon"
               fullname="reco::Muon"
               module="DataFormats.MuonReco"
               project=""
               type="regular">
            <baseclass name="public RecoCandidate"/>

            <section name="public">
                <constructor name="Muon"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
Muon();
                </constructor>

                <constructor name="Muon"
                             return=""
                             args="['Charge','const LorentzVector&amp;','const Point&amp;=Point(0, 0, 0)']"
                             vars="['','','']"
                             qual="">
Muon(Charge, const LorentzVector&amp;, const Point&amp;=Point(0, 0, 0));
                    <comment>
        constructor from values
                    </comment>
                </constructor>

                <method1 name="clone"
                         return="Muon*"
                         args="['void']"
                         vars="['']"
                         qual="const">
Muon* clone() const;
                    <comment>
        create a clone
                    </comment>
                </method1>

                <method1 name="innerTrack"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual TrackRef innerTrack() const;
                    <comment>
        reference to Track reconstructed in the tracker only
                    </comment>
                </method1>

                <method1 name="track"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const ">
virtual TrackRef track() const ;
                </method1>

                <method1 name="outerTrack"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual TrackRef outerTrack() const;
                    <comment>
        reference to Track reconstructed in the muon detector only
                    </comment>
                </method1>

                <method1 name="standAloneMuon"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const ">
virtual TrackRef standAloneMuon() const ;
                </method1>

                <method1 name="globalTrack"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const">
virtual TrackRef globalTrack() const;
                    <comment>
        reference to Track reconstructed in both tracked and muon detector
                    </comment>
                </method1>

                <method1 name="combinedMuon"
                         return="virtual TrackRef"
                         args="['void']"
                         vars="['']"
                         qual="const ">
virtual TrackRef combinedMuon() const ;
                </method1>

                <method1 name="setInnerTrack"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setInnerTrack(const TrackRef&amp; t);
                    <comment>
        set reference to Track
                    </comment>
                </method1>

                <method1 name="setTrack"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setTrack(const TrackRef&amp; t) ;
                </method1>

                <method1 name="setOuterTrack"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setOuterTrack(const TrackRef&amp; t);
                    <comment>
        set reference to Track
                    </comment>
                </method1>

                <method1 name="setStandAlone"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setStandAlone(const TrackRef&amp; t) ;
                </method1>

                <method1 name="setGlobalTrack"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setGlobalTrack(const TrackRef&amp; t);
                    <comment>
        set reference to Track
                    </comment>
                </method1>

                <method1 name="setCombined"
                         return="virtual void"
                         args="['const TrackRef&amp;']"
                         vars="['t']"
                         qual="">
virtual void setCombined(const TrackRef&amp; t) ;
                </method1>

                <method1 name="isEnergyValid"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isEnergyValid() const;
                    <comment>
        energy deposition
                    </comment>
                </method1>

                <method1 name="calEnergy"
                         return="MuonEnergy"
                         args="['void']"
                         vars="['']"
                         qual="const">
MuonEnergy calEnergy() const;
                    <comment>
        get energy deposition information
                    </comment>
                </method1>

                <method1 name="setCalEnergy"
                         return="void"
                         args="['const MuonEnergy&amp;']"
                         vars="['calEnergy']"
                         qual="">
void setCalEnergy(const MuonEnergy&amp; calEnergy);
                    <comment>
        set energy deposition information
                    </comment>
                </method1>

                <method1 name="isTimeValid"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isTimeValid() const;
                    <comment>
        timing information
                    </comment>
                </method1>

                <method1 name="time"
                         return="MuonTime"
                         args="['void']"
                         vars="['']"
                         qual="const">
MuonTime time() const;
                    <comment>
        get timing information
                    </comment>
                </method1>

                <method1 name="setTime"
                         return="void"
                         args="['const MuonTime&amp;']"
                         vars="['time']"
                         qual="">
void setTime(const MuonTime&amp; time);
                    <comment>
        set timing information
                    </comment>
                </method1>

                <method1 name="isMatchesValid"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isMatchesValid() const;
                    <comment>
        ====================== MUON MATCH BLOCK ===========================
                    </comment>
                </method1>

                <method2 name="matches"
                         return="std::vector&lt;MuonChamberMatch&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="">
std::vector&lt;MuonChamberMatch&gt;&amp; matches();
                    <comment>
        get muon matching information
                    </comment>
                </method2>

                <method2 name="matches"
                         return="const std::vector&lt;MuonChamberMatch&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;MuonChamberMatch&gt;&amp; matches() const;
                </method2>

                <method2 name="setMatches"
                         return="void"
                         args="['const std::vector&lt;MuonChamberMatch&gt;&amp;']"
                         vars="['matches']"
                         qual="">
void setMatches(const std::vector&lt;MuonChamberMatch&gt;&amp; matches);
                    <comment>
        set muon matching information
                    </comment>
                </method2>

                <method1 name="caloCompatibility"
                         return="float"
                         args="['void']"
                         vars="['']"
                         qual="const">
float caloCompatibility() const;
                    <comment>
        L_muon/(L_muon+L_not_muon)
                    </comment>
                </method1>

                <method1 name="setCaloCompatibility"
                         return="void"
                         args="['float']"
                         vars="['input']"
                         qual="">
void setCaloCompatibility(float input);
                </method1>

                <method1 name="isCaloCompatibilityValid"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isCaloCompatibilityValid() const;
                </method1>

                <method1 name="segmentCompatibility"
                         return="float"
                         args="['void']"
                         vars="['']"
                         qual="const">
float segmentCompatibility() const;
                </method1>

                <method1 name="isolationR03"
                         return="const MuonIsolation&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const MuonIsolation&amp; isolationR03() const;
                    <comment>
        Summary of muon isolation information
                    </comment>
                </method1>

                <method1 name="isolationR05"
                         return="const MuonIsolation&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const MuonIsolation&amp; isolationR05() const;
                </method1>

                <method1 name="setIsolation"
                         return="void"
                         args="['const MuonIsolation&amp;','const MuonIsolation&amp;']"
                         vars="['isoR03','isoR05']"
                         qual="">
void setIsolation(const MuonIsolation&amp; isoR03, const MuonIsolation&amp; isoR05);
                </method1>

                <method1 name="isIsolationValid"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isIsolationValid() const;
                </method1>

                <enum name="SelectionType">
enum SelectionType {

         All, 
         AllGlobalMuons, 
         AllStandAloneMuons, 
         AllTrackerMuons, 
  TrackerMuonArbitrated, 
         AllArbitrated, 
         GlobalMuonPromptTight, 
  TMLastStationLoose, 
  TMLastStationTight, 
  TM2DCompatibilityLoose, 
  TM2DCompatibilityTight, 
         TMOneStationLoose, 
         TMOneStationTight, 
         TMLastStationOptimizedLowPtLoose, 
         TMLastStationOptimizedLowPtTight
    };
                    <field name="All" value=""/>
                    <field name="AllGlobalMuons" value=""/>
                    <field name="AllStandAloneMuons" value=""/>
                    <field name="AllTrackerMuons" value=""/>
                    <field name="TrackerMuonArbitrated" value=""/>
                    <field name="AllArbitrated" value=""/>
                    <field name="GlobalMuonPromptTight" value=""/>
                    <field name="TMLastStationLoose" value=""/>
                    <field name="TMLastStationTight" value=""/>
                    <field name="TM2DCompatibilityLoose" value=""/>
                    <field name="TM2DCompatibilityTight" value=""/>
                    <field name="TMOneStationLoose" value=""/>
                    <field name="TMOneStationTight" value=""/>
                    <field name="TMLastStationOptimizedLowPtLoose" value=""/>
                    <field name="TMLastStationOptimizedLowPtTight" value=""/>
                    <comment>
        object
                    </comment>
                </enum>

                <method1 name="isGood"
                         return="bool"
                         args="['SelectionType=AllArbitrated']"
                         vars="['type']"
                         qual="const">
bool isGood(SelectionType type=AllArbitrated) const;
                </method1>

                <enum name="ArbitrationType">
enum ArbitrationType {
 NoArbitration, SegmentArbitration, SegmentAndTrackArbitration };
                    <field name="NoArbitration" value=""/>
                    <field name="SegmentArbitration" value=""/>
                    <field name="SegmentAndTrackArbitration" value=""/>
                    <comment>
        define arbitration schemes
                    </comment>
                </enum>

                <method1 name="numberOfChambers"
                         return="int"
                         args="['void']"
                         vars="['']"
                         qual="const">
int numberOfChambers() const;
                    <comment>
        number of chambers
                    </comment>
                </method1>

                <method1 name="numberOfMatches"
                         return="int"
                         args="['ArbitrationType=SegmentArbitration']"
                         vars="['type']"
                         qual="const">
int numberOfMatches(ArbitrationType type=SegmentArbitration) const;
                    <comment>
        get number of chambers with matched segments
                    </comment>
                </method1>

                <method1 name="stationMask"
                         return="unsigned int"
                         args="['ArbitrationType=SegmentArbitration']"
                         vars="['type']"
                         qual="const">
unsigned int stationMask(ArbitrationType type=SegmentArbitration) const;
                    <comment>
        bits 4-5-6-7 = CSC stations 1-2-3-4
                    </comment>
                </method1>

                <method1 name="stationGapMaskDistance"
                         return="unsigned int"
                         args="['float=10.']"
                         vars="['distanceCut']"
                         qual="const">
unsigned int stationGapMaskDistance(float distanceCut=10.) const;
                    <comment>
        bit assignments are same as above
                    </comment>
                </method1>

                <method1 name="stationGapMaskPull"
                         return="unsigned int"
                         args="['float=3.']"
                         vars="['sigmaCut']"
                         qual="const">
unsigned int stationGapMaskPull(float sigmaCut=3.) const;
                    <comment>
        same as above for given number of sigmas
                    </comment>
                </method1>

                <constant name="GlobalMuon"
                          type="static const unsigned int"
                          value="1&amp;lt;&amp;lt;1"/>
                <constant name="TrackerMuon"
                          type="static const unsigned int"
                          value="1&amp;lt;&amp;lt;2"/>
                <constant name="StandAloneMuon"
                          type="static const unsigned int"
                          value="1&amp;lt;&amp;lt;3"/>
                <constant name="CaloMuon"
                          type="static const unsigned int"
                          value="1&amp;lt;&amp;lt;4"/>
                <method1 name="setType"
                         return="void"
                         args="['unsigned int']"
                         vars="['type']"
                         qual="">
void setType(unsigned int type);
                </method1>

                <method1 name="type"
                         return="unsigned int"
                         args="['void']"
                         vars="['']"
                         qual="const">
unsigned int type() const;
                </method1>

                <method1 name="isMuon"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isMuon() const;
                    <comment>
       override of method in base class reco::Candidate
                    </comment>
                </method1>

                <method1 name="isGlobalMuon"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isGlobalMuon() const;
                </method1>

                <method1 name="isTrackerMuon"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isTrackerMuon() const;
                </method1>

                <method1 name="isStandAloneMuon"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isStandAloneMuon() const;
                </method1>

                <method1 name="isCaloMuon"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isCaloMuon() const;
                </method1>

            </section>
            <section name="public">
                <method1 name="numberOfSegments"
                         return="int"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
int numberOfSegments(int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                    <comment>
         get number of segments
                    </comment>
                </method1>

                <method1 name="dX"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float dX (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                    <comment>
         If no chamber or no segment returns 999999
                    </comment>
                </method1>

                <method1 name="dY"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float dY (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="dDxDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float dDxDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="dDyDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float dDyDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="pullX"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration','bool=false']"
                         vars="['station','muonSubdetId','type','includeSegmentError']"
                         qual="const">
float pullX (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration, bool includeSegmentError=false) const;
                </method1>

                <method1 name="pullY"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration','bool=false']"
                         vars="['station','muonSubdetId','type','includeSegmentError']"
                         qual="const">
float pullY (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration, bool includeSegmentError=false) const;
                </method1>

                <method1 name="pullDxDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration','bool=false']"
                         vars="['station','muonSubdetId','type','includeSegmentError']"
                         qual="const">
float pullDxDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration, bool includeSegmentError=false) const;
                </method1>

                <method1 name="pullDyDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration','bool=false']"
                         vars="['station','muonSubdetId','type','includeSegmentError']"
                         qual="const">
float pullDyDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration, bool includeSegmentError=false) const;
                </method1>

                <method1 name="segmentX"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentX (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                    <comment>
         If no segment returns 999999
                    </comment>
                </method1>

                <method1 name="segmentY"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentY (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentDxDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentDxDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentDyDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentDyDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentXErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentXErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentYErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentYErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentDxDzErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentDxDzErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="segmentDyDzErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float segmentDyDzErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackEdgeX"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackEdgeX (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                    <comment>
         If no chamber returns 999999
                    </comment>
                </method1>

                <method1 name="trackEdgeY"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackEdgeY (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackX"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackX (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackY"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackY (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDxDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDxDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDyDz"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDyDz (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackXErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackXErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackYErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackYErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDxDzErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDxDzErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDyDzErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDyDzErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDist"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDist (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="trackDistErr"
                         return="float"
                         args="['int','int','ArbitrationType=SegmentArbitration']"
                         vars="['station','muonSubdetId','type']"
                         qual="const">
float trackDistErr (int station, int muonSubdetId, ArbitrationType type=SegmentArbitration) const;
                </method1>

                <method1 name="t0"
                         return="float"
                         args="['int=0']"
                         vars="['n']"
                         qual="">
float t0(int n=0);
                </method1>

            </section>

            <typemap name="All"
                     value="reco::Muon::All"
                     type="enum"/>
            <typemap name="AllArbitrated"
                     value="reco::Muon::AllArbitrated"
                     type="enum"/>
            <typemap name="AllGlobalMuons"
                     value="reco::Muon::AllGlobalMuons"
                     type="enum"/>
            <typemap name="AllStandAloneMuons"
                     value="reco::Muon::AllStandAloneMuons"
                     type="enum"/>
            <typemap name="AllTrackerMuons"
                     value="reco::Muon::AllTrackerMuons"
                     type="enum"/>
            <typemap name="ArbitrationType"
                     value="reco::Muon::ArbitrationType"
                     type="enum"/>
            <typemap name="GlobalMuonPromptTight"
                     value="reco::Muon::GlobalMuonPromptTight"
                     type="enum"/>
            <typemap name="NoArbitration"
                     value="reco::Muon::NoArbitration"
                     type="enum"/>
            <typemap name="SegmentAndTrackArbitration"
                     value="reco::Muon::SegmentAndTrackArbitration"
                     type="enum"/>
            <typemap name="SegmentArbitration"
                     value="reco::Muon::SegmentArbitration"
                     type="enum"/>
            <typemap name="SelectionType"
                     value="reco::Muon::SelectionType"
                     type="enum"/>
            <typemap name="TM2DCompatibilityLoose"
                     value="reco::Muon::TM2DCompatibilityLoose"
                     type="enum"/>
            <typemap name="TM2DCompatibilityTight"
                     value="reco::Muon::TM2DCompatibilityTight"
                     type="enum"/>
            <typemap name="TMLastStationLoose"
                     value="reco::Muon::TMLastStationLoose"
                     type="enum"/>
            <typemap name="TMLastStationOptimizedLowPtLoose"
                     value="reco::Muon::TMLastStationOptimizedLowPtLoose"
                     type="enum"/>
            <typemap name="TMLastStationOptimizedLowPtTight"
                     value="reco::Muon::TMLastStationOptimizedLowPtTight"
                     type="enum"/>
            <typemap name="TMLastStationTight"
                     value="reco::Muon::TMLastStationTight"
                     type="enum"/>
            <typemap name="TMOneStationLoose"
                     value="reco::Muon::TMOneStationLoose"
                     type="enum"/>
            <typemap name="TMOneStationTight"
                     value="reco::Muon::TMOneStationTight"
                     type="enum"/>
            <typemap name="TrackerMuonArbitrated"
                     value="reco::Muon::TrackerMuonArbitrated"
                     type="enum"/>

        </class>
    </namespace>

    <type name="ArbitrationType"/>
    <type name="Charge"/>
    <type name="Muon*"/>
    <type name="MuonEnergy"/>
    <type name="MuonTime"/>
    <type name="RecoCandidate"/>
    <type name="SelectionType"/>
    <type name="TrackRef"/>
    <type name="bool"/>
    <type name="const LorentzVector&amp;"/>
    <type name="const MuonEnergy&amp;"/>
    <type name="const MuonIsolation&amp;"/>
    <type name="const MuonTime&amp;"/>
    <type name="const Point&amp;"/>
    <type name="const TrackRef&amp;"/>
    <type name="const std::vector&lt;MuonChamberMatch&gt;&amp;"/>
    <type name="enum ArbitrationType"/>
    <type name="enum SelectionType"/>
    <type name="float"/>
    <type name="int"/>
    <type name="reco::Muon"/>
    <type name="std::vector&lt;MuonChamberMatch&gt;&amp;"/>
    <type name="unsigned int"/>
    <type name="void"/>
</header>
