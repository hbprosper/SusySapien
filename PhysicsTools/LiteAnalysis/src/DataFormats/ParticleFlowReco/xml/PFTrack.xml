<?xml version="1.0"?>
<!--
==============================================================================
  XML File: PFTrack.xml
  Created:  Fri Jan 15 20:47:05 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/ParticleFlowReco/interface/PFTrack.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/ParticleFlowReco/interface/PFTrack.h">

    <include name="&quot;DataFormats/ParticleFlowReco/interface/PFTrajectoryPoint.h&quot;"/>
    <include name="&lt;iostream&gt;"/>
    <include name="&lt;vector&gt;"/>

    <namespace name="reco">

        <class name="PFTrack"
               fullname="reco::PFTrack"
               module="DataFormats.ParticleFlowReco"
               project=""
               type="regular printable">
            <comment>
     \class PFTrack
     \brief  Base class for particle flow input reconstructed tracks
     and simulated particles.

     A PFTrack contains a vector of PFTrajectoryPoint objects.
     These points are stored in a vector to benefit from the
     random access. One must take care of storing the points in
     the right order, and it might even be necessary to insert dummy points.

     For a PFRecTrack, the ordering of the points is the following:

     - point 1: Closest approach

     - point 2: Beam Pipe

     - point 3 to n: Trajectory measurements (from the tracker layers)

     - point n+1: Preshower Layer 1, or dummy point if
     not in the preshower zone

     - point n+2: Preshower Layer 2, or dummy point if
     not in the preshower zone

     - point n+3: ECAL Entrance

     - point n+4: ECAL expected position of the shower maximum,
     assuming the track is an electron track.

     - point n+5: HCAL Entrance

     For a PFSimParticle, the ordering of the points is the following.

     - If the particle decays before ECAL:
     - point 1: start point
     - point 2: end point

     - If the particle does not decay before ECAL:
     - point 1: start point
     - point 2: PS1 or dummy
     - point 3: PS2 or dummy
     - point 4: ECAL entrance
     - point 5: HCAL entrance


     \todo Note that some points are missing, and should be added: shower max,
     intersection with the tracker layers maybe.

     PFRecTracks and PFSimParticles are created in the PFTrackProducer module.
     \todo   Make this class abstract ?
     \author Renaud Bruneliere
     \date   July 2006
            </comment>

            <section name="public">
                <constructor name="PFTrack"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
PFTrack();
                </constructor>

                <constructor name="PFTrack"
                             return=""
                             args="['double']"
                             vars="['charge']"
                             qual="">
PFTrack(double charge);
                </constructor>

                <copyconstructor name="PFTrack"
                                 return=""
                                 args="['const PFTrack&amp;']"
                                 vars="['other']"
                                 qual="">
PFTrack(const PFTrack&amp; other);
                </copyconstructor>

                <method1 name="addPoint"
                         return="void"
                         args="['const reco::PFTrajectoryPoint&amp;']"
                         vars="['trajPt']"
                         qual="">
void addPoint(const reco::PFTrajectoryPoint&amp; trajPt);
                    <comment>
          \todo throw an exception if the number of points is too large
                    </comment>
                </method1>

                <method1 name="setPoint"
                         return="void"
                         args="['unsigned int','const reco::PFTrajectoryPoint&amp;']"
                         vars="['index','measurement']"
                         qual="">
void setPoint(unsigned int index, const reco::PFTrajectoryPoint&amp; measurement);
                    <comment>
          set a trajectory point
                    </comment>
                </method1>

                <method1 name="calculatePositionREP"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void calculatePositionREP();
                    <comment>
          \todo where is posrep? profile and see if it's necessary.
                    </comment>
                </method1>

                <method1 name="charge"
                         return="double"
                         args="['void']"
                         vars="['']"
                         qual="const">
double charge() const;
                    <comment>
          \return electric charge
                    </comment>
                </method1>

                <method1 name="nTrajectoryPoints"
                         return="unsigned int"
                         args="['void']"
                         vars="['']"
                         qual="const">
unsigned int nTrajectoryPoints() const;
                    <comment>
          \return number of trajectory points
                    </comment>
                </method1>

                <method1 name="nTrajectoryMeasurements"
                         return="unsigned int"
                         args="['void']"
                         vars="['']"
                         qual="const">
unsigned int nTrajectoryMeasurements() const;
                    <comment>
          \return number of trajectory measurements in tracker
                    </comment>
                </method1>

                <method2 name="trajectoryPoints"
                         return="const std::vector&lt;reco::PFTrajectoryPoint &gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;reco::PFTrajectoryPoint &gt;&amp; trajectoryPoints() const;
                    <comment>
          \return vector of trajectory points
                    </comment>
                </method2>

                <method1 name="trajectoryPoint"
                         return="const reco::PFTrajectoryPoint&amp;"
                         args="['unsigned']"
                         vars="['index']"
                         qual="const">
const reco::PFTrajectoryPoint&amp; trajectoryPoint(unsigned index) const;
                    <comment>
          \return a trajectory point
                    </comment>
                </method1>

                <method1 name="extrapolatedPoint"
                         return="const reco::PFTrajectoryPoint&amp;"
                         args="['unsigned']"
                         vars="['layerid']"
                         qual="const">
const reco::PFTrajectoryPoint&amp; extrapolatedPoint(unsigned layerid) const;
                    <comment>
          \todo throw an exception in case of invalid point.
                    </comment>
                </method1>

                <method2 name="innermostMeasurement"
                         return="std::vector&lt;reco::PFTrajectoryPoint &gt;::const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
std::vector&lt;reco::PFTrajectoryPoint &gt;::const_iterator         innermostMeasurement() const;
                    <comment>
          iterator on innermost tracker measurement
                    </comment>
                </method2>

                <method2 name="outermostMeasurement"
                         return="std::vector&lt;reco::PFTrajectoryPoint &gt;::const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
std::vector&lt;reco::PFTrajectoryPoint &gt;::const_iterator         outermostMeasurement() const;
                    <comment>
          iterator on outermost tracker measurement
                    </comment>
                </method2>

                <method1 name="setColor"
                         return="void"
                         args="['int']"
                         vars="['color']"
                         qual="">
void setColor(int color);
                </method1>

                <method1 name="color"
                         return="int"
                         args="['void']"
                         vars="['']"
                         qual="const">
int color() const;
                </method1>

                <operator name="operator&lt;&lt;"
                          return="friend std::ostream&amp;"
                          args="['std::ostream&amp;','const PFTrack&amp;']"
                          vars="['out','track']"
                          qual="">
friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const PFTrack&amp; track);
                </operator>

            </section>
            <section name="protected">
                <constant name="nMaxTrackingLayers_"
                          type="static const unsigned int"
                          value=""/>
            </section>

        </class>
    </namespace>

    <type name="const PFTrack&amp;"/>
    <type name="const reco::PFTrajectoryPoint&amp;"/>
    <type name="const std::vector&lt;reco::PFTrajectoryPoint &gt;&amp;"/>
    <type name="double"/>
    <type name="int"/>
    <type name="reco::PFTrack"/>
    <type name="std::ostream&amp;"/>
    <type name="std::vector&lt;reco::PFTrajectoryPoint &gt;::const_iterator"/>
    <type name="unsigned"/>
    <type name="unsigned int"/>
    <type name="void"/>
</header>
