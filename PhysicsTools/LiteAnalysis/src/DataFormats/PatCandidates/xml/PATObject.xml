<?xml version="1.0"?>
<!--
==============================================================================
  XML File: PATObject.xml
  Created:  Thu Jan 14 22:48:16 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/PatCandidates/interface/PATObject.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/PatCandidates/interface/PATObject.h">

    <include name="&quot;DataFormats/Common/interface/Ptr.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/CandidateFwd.h&quot;"/>
    <include name="&quot;DataFormats/Candidate/interface/Candidate.h&quot;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&lt;string&gt;"/>
    <include name="&quot;DataFormats/PatCandidates/interface/TriggerPrimitive.h&quot;"/>
    <include name="&quot;DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h&quot;"/>
    <include name="&quot;DataFormats/PatCandidates/interface/LookupTableRecord.h&quot;"/>
    <include name="&quot;DataFormats/HepMCCandidate/interface/GenParticle.h&quot;"/>
    <include name="&quot;DataFormats/PatCandidates/interface/UserData.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OwnVector.h&quot;"/>
    <include name="&quot;DataFormats/PatCandidates/interface/CandKinResolution.h&quot;"/>

    <namespace name="pat">

        <class name="PATObject"
               fullname="pat::PATObject&lt;ObjectType&gt;"
               module="DataFormats.PatCandidates"
               project=""
               type="template"
               template="template&lt;class ObjectType&gt;">
            <baseclass name="public ObjectType"/>

            <section name="public">
                <typedef name="base_type"
                         value="ObjectType">
typedef ObjectType base_type;
                </typedef>

                <constructor name="PATObject"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
PATObject();
                    <comment>
          default constructor
                    </comment>
                </constructor>

                <constructor name="PATObject"
                             return=""
                             args="['const ObjectType&amp;']"
                             vars="['obj']"
                             qual="">
PATObject(const ObjectType&amp; obj);
                    <comment>
          constructor from a base object (leaves invalid reference to original object!)
                    </comment>
                </constructor>

                <constructor name="PATObject"
                             return=""
                             args="['const edm::RefToBase&lt;ObjectType&gt;&amp;']"
                             vars="['ref']"
                             qual="">
PATObject(const edm::RefToBase&lt;ObjectType&gt;&amp; ref);
                    <comment>
          constructor from reference
                    </comment>
                </constructor>

                <constructor name="PATObject"
                             return=""
                             args="['const edm::Ptr&lt;ObjectType&gt;&amp;']"
                             vars="['ref']"
                             qual="">
PATObject(const edm::Ptr&lt;ObjectType&gt;&amp; ref);
                    <comment>
          constructor from reference
                    </comment>
                </constructor>

                <destructor name="~PATObject"
                            return="virtual"
                            args="['void']"
                            vars="['']"
                            qual="">
virtual ~PATObject();
                    <comment>
          destructor
                    </comment>
                </destructor>

                <method1 name="originalObject"
                         return="const reco::Candidate*"
                         args="['void']"
                         vars="['']"
                         qual="const">
const reco::Candidate* originalObject() const;
                    <comment>
          access to the original object; returns zero for null Ref and throws for unavailable collection
                    </comment>
                </method1>

                <method2 name="originalObjectRef"
                         return="const edm::Ptr&lt;reco::Candidate&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const edm::Ptr&lt;reco::Candidate&gt;&amp; originalObjectRef() const;
                    <comment>
          reference to original object. Returns a null reference if not available
                    </comment>
                </method2>

                <method2 name="triggerMatches"
                         return="const std::vector&lt;TriggerPrimitive&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;TriggerPrimitive&gt;&amp; triggerMatches() const;
                    <comment>
          old trigger matches
                    </comment>
                </method2>

                <method2 name="triggerMatchesByFilter"
                         return="const std::vector&lt;TriggerPrimitive&gt;"
                         args="['const std::string&amp;']"
                         vars="['aFilt']"
                         qual="const">
const std::vector&lt;TriggerPrimitive&gt; triggerMatchesByFilter(const std::string&amp; aFilt) const;
                </method2>

                <method1 name="addTriggerMatch"
                         return="void"
                         args="['const pat::TriggerPrimitive&amp;']"
                         vars="['aTrigPrim']"
                         qual="">
void addTriggerMatch(const pat::TriggerPrimitive&amp; aTrigPrim);
                    <comment>
          add an old trigger match
                    </comment>
                </method1>

                <method1 name="triggerObjectMatches"
                         return="const TriggerObjectStandAloneCollection&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const TriggerObjectStandAloneCollection&amp; triggerObjectMatches() const;
                    <comment>
          embedded trigger matches
                    </comment>
                </method1>

                <method1 name="triggerObjectMatchesByFilterID"
                         return="const TriggerObjectStandAloneCollection"
                         args="['const unsigned']"
                         vars="['id']"
                         qual="const">
const TriggerObjectStandAloneCollection triggerObjectMatchesByFilterID(const unsigned id) const;
                </method1>

                <method1 name="triggerObjectMatchesByCollection"
                         return="const TriggerObjectStandAloneCollection"
                         args="['const std::string&amp;']"
                         vars="['coll']"
                         qual="const">
const TriggerObjectStandAloneCollection triggerObjectMatchesByCollection(const std::string&amp; coll) const;
                </method1>

                <method1 name="triggerObjectMatchesByFilter"
                         return="const TriggerObjectStandAloneCollection"
                         args="['const std::string&amp;']"
                         vars="['labelFilter']"
                         qual="const">
const TriggerObjectStandAloneCollection triggerObjectMatchesByFilter(const std::string&amp; labelFilter) const;
                </method1>

                <method1 name="triggerObjectMatchesByPath"
                         return="const TriggerObjectStandAloneCollection"
                         args="['const std::string&amp;']"
                         vars="['namePath']"
                         qual="const">
const TriggerObjectStandAloneCollection triggerObjectMatchesByPath(const std::string&amp; namePath) const;
                </method1>

                <method1 name="addTriggerObjectMatch"
                         return="void"
                         args="['const TriggerObjectStandAlone&amp;']"
                         vars="['trigObj']"
                         qual="">
void addTriggerObjectMatch(const TriggerObjectStandAlone&amp; trigObj);
                    <comment>
          add a trigger match
                    </comment>
                </method1>

                <method1 name="efficiency"
                         return="const pat::LookupTableRecord&amp;"
                         args="['const std::string&amp;']"
                         vars="['name']"
                         qual="const">
const pat::LookupTableRecord&amp; efficiency(const std::string&amp; name) const;
                    <comment>
          Returns an efficiency given its name
                    </comment>
                </method1>

                <method2 name="efficiencies"
                         return="std::vector&lt;std::pair&lt;std::string, pat::LookupTableRecord&gt; &gt;"
                         args="['void']"
                         vars="['']"
                         qual="const">
std::vector&lt;std::pair&lt;std::string, pat::LookupTableRecord&gt; &gt; efficiencies() const;
                    <comment>
          Returns the efficiencies as &lt;name,value&gt; pairs (by value)
                    </comment>
                </method2>

                <method2 name="efficiencyNames"
                         return="const std::vector&lt;std::string&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;std::string&gt;&amp; efficiencyNames() const;
                    <comment>
          Returns the list of the names of the stored efficiencies
                    </comment>
                </method2>

                <method2 name="efficiencyValues"
                         return="const std::vector&lt;pat::LookupTableRecord&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;pat::LookupTableRecord&gt;&amp; efficiencyValues() const;
                    <comment>
          Returns the list of the values of the stored efficiencies (the ordering is the same as in efficiencyNames())
                    </comment>
                </method2>

                <method1 name="setEfficiency"
                         return="void"
                         args="['const std::string&amp;','const pat::LookupTableRecord&amp;']"
                         vars="['name','value']"
                         qual="">
void setEfficiency(const std::string&amp; name, const pat::LookupTableRecord&amp; value);
                    <comment>
          Calling this method many times with names not sorted alphabetically will be slow
                    </comment>
                </method1>

                <method1 name="genParticleRef"
                         return="reco::GenParticleRef"
                         args="['size_t=0']"
                         vars="['idx']"
                         qual="const">
reco::GenParticleRef genParticleRef(size_t idx=0) const;
                    <comment>
          If you stored multiple GenParticles, you can specify which one you want.
                    </comment>
                </method1>

                <method1 name="genParticleById"
                         return="reco::GenParticleRef"
                         args="['int','int']"
                         vars="['pdgId','status']"
                         qual="const">
reco::GenParticleRef genParticleById(int pdgId, int status) const;
                    <comment>
          Note: this might be a transient ref if the genParticle was embedded
                    </comment>
                </method1>

                <method1 name="genParticle"
                         return="const reco::GenParticle*"
                         args="['size_t=0']"
                         vars="['idx']"
                         qual="const">
const reco::GenParticle* genParticle(size_t idx=0) const;
                    <comment>
          If you stored multiple GenParticles, you can specify which one you want.
                    </comment>
                </method1>

                <method1 name="genParticlesSize"
                         return="size_t"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_t genParticlesSize() const;
                    <comment>
          Number of generator level particles stored as ref or embedded
                    </comment>
                </method1>

                <method2 name="genParticleRefs"
                         return="std::vector&lt;reco::GenParticleRef&gt;"
                         args="['void']"
                         vars="['']"
                         qual="const">
std::vector&lt;reco::GenParticleRef&gt; genParticleRefs() const;
                    <comment>
          Note that the refs can be transient refs to embedded GenParticles
                    </comment>
                </method2>

                <method1 name="setGenParticleRef"
                         return="void"
                         args="['const reco::GenParticleRef&amp;','bool=false']"
                         vars="['ref','embed']"
                         qual="">
void setGenParticleRef(const reco::GenParticleRef&amp; ref, bool embed=false);
                    <comment>
          Set the generator level particle reference
                    </comment>
                </method1>

                <method1 name="addGenParticleRef"
                         return="void"
                         args="['const reco::GenParticleRef&amp;']"
                         vars="['ref']"
                         qual="">
void addGenParticleRef(const reco::GenParticleRef&amp; ref);
                    <comment>
          If there is already an embedded particle, this ref will be embedded too
                    </comment>
                </method1>

                <method1 name="setGenParticle"
                         return="void"
                         args="['const reco::GenParticle&amp;']"
                         vars="['particle']"
                         qual="">
void setGenParticle(const reco::GenParticle&amp; particle);
                    <comment>
          Set the generator level particle from a particle not in the Event (embedding it, of course)
                    </comment>
                </method1>

                <method1 name="embedGenParticle"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void embedGenParticle();
                    <comment>
          Note that generator level particles can only be all embedded or all not embedded.
                    </comment>
                </method1>

                <method1 name="hasOverlaps"
                         return="bool"
                         args="['const std::string&amp;']"
                         vars="['label']"
                         qual="const">
bool hasOverlaps(const std::string&amp; label) const;
                    <comment>
          Returns true if there was at least one overlap for this test label
                    </comment>
                </method1>

                <method1 name="overlaps"
                         return="const reco::CandidatePtrVector&amp;"
                         args="['const std::string&amp;']"
                         vars="['label']"
                         qual="const">
const reco::CandidatePtrVector&amp; overlaps(const std::string&amp; label) const;
                    <comment>
          The original ordering of items is kept (usually it's by increasing deltaR from this item)
                    </comment>
                </method1>

                <method2 name="overlapLabels"
                         return="const std::vector&lt;std::string&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;std::string&gt;&amp; overlapLabels() const;
                    <comment>
          Returns the labels of the overlap tests that found at least one overlap
                    </comment>
                </method2>

                <method1 name="setOverlaps"
                         return="void"
                         args="['const std::string&amp;','const reco::CandidatePtrVector&amp;']"
                         vars="['label','overlaps']"
                         qual="">
void setOverlaps(const std::string&amp; label, const reco::CandidatePtrVector&amp; overlaps);
                    <comment>
          Items within the list should already be sorted appropriately (this method won't sort them)
                    </comment>
                </method1>

                <method2 name="userData"
                         return="template&lt;typename T&gt; const T*"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
template&lt;typename T&gt; const T* userData(const std::string&amp; key) const;
                    <comment>
          Returns user-defined data. Returns NULL if the data is not present, or not of type T.
                    </comment>
                </method2>

                <method1 name="hasUserData"
                         return="bool"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
bool hasUserData(const std::string&amp; key) const;
                    <comment>
          Check if user data with a specific type is present
                    </comment>
                </method1>

                <method1 name="userDataObjectType"
                         return="const std::string&amp;"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
const std::string&amp; userDataObjectType(const std::string&amp; key) const;
                    <comment>
          Get human-readable type of user data object, for debugging
                    </comment>
                </method1>

                <method2 name="userDataNames"
                         return="const std::vector&lt;std::string&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;std::string&gt;&amp; userDataNames() const;
                    <comment>
          Get list of user data object names
                    </comment>
                </method2>

                <method1 name="userDataBare"
                         return="const void*"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
const void* userDataBare(const std::string&amp; key) const;
                    <comment>
          COMPLETELY UNSUPPORTED, USE ONLY FOR DEBUGGING
                    </comment>
                </method1>

                <method2 name="addUserData"
                         return="template&lt;typename T&gt; void"
                         args="['const std::string&amp;','const T&amp;','bool=false']"
                         vars="['label','data','transientOnly']"
                         qual="">
template&lt;typename T&gt;       void addUserData(const std::string&amp; label, const T&amp; data, bool transientOnly=false);
                    <comment>
          unless transientOnly is set to true
                    </comment>
                </method2>

                <method2 name="addUserDataFromPtr"
                         return="void"
                         args="['const std::string&amp;','const edm::Ptr&lt;pat::UserData&gt;&amp;']"
                         vars="['label','data']"
                         qual="">
void addUserDataFromPtr(const std::string&amp; label, const edm::Ptr&lt;pat::UserData&gt;&amp; data);
                    <comment>
          Do not use unless you know what you are doing.
                    </comment>
                </method2>

                <method1 name="userFloat"
                         return="float"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
float userFloat(const std::string&amp; key) const;
                    <comment>
          Note: it will return 0.0 if the key is not found; you can check if the key exists with 'hasUserFloat' method.
                    </comment>
                </method1>

                <method1 name="addUserFloat"
                         return="void"
                         args="['const std::string&amp;','float']"
                         vars="['label','data']"
                         qual="">
void addUserFloat(const std::string&amp; label, float data);
                    <comment>
          Set user-defined float
                    </comment>
                </method1>

                <method2 name="userFloatNames"
                         return="const std::vector&lt;std::string&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;std::string&gt;&amp; userFloatNames() const;
                    <comment>
          Get list of user-defined float names
                    </comment>
                </method2>

                <method1 name="hasUserFloat"
                         return="bool"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
bool hasUserFloat(const std::string&amp; key) const;
                    <comment>
          Return true if there is a user-defined float with a given name
                    </comment>
                </method1>

                <method1 name="userInt"
                         return="int32_t"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
int32_t userInt(const std::string&amp; key) const;
                    <comment>
          Note: it will return 0 if the key is not found; you can check if the key exists with 'hasUserInt' method.
                    </comment>
                </method1>

                <method1 name="addUserInt"
                         return="void"
                         args="['const std::string&amp;','int32_t']"
                         vars="['label','data']"
                         qual="">
void addUserInt(const std::string&amp; label, int32_t data);
                    <comment>
          Set user-defined int
                    </comment>
                </method1>

                <method2 name="userIntNames"
                         return="const std::vector&lt;std::string&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const std::vector&lt;std::string&gt;&amp; userIntNames() const;
                    <comment>
          Get list of user-defined int names
                    </comment>
                </method2>

                <method1 name="hasUserInt"
                         return="bool"
                         args="['const std::string&amp;']"
                         vars="['key']"
                         qual="const">
bool hasUserInt(const std::string&amp; key) const;
                    <comment>
          Return true if there is a user-defined int with a given name
                    </comment>
                </method1>

                <method1 name="getKinResolution"
                         return="const pat::CandKinResolution&amp;"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
const pat::CandKinResolution&amp; getKinResolution(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          If not present, it will throw an exception.
                    </comment>
                </method1>

                <method1 name="hasKinResolution"
                         return="bool"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
bool hasKinResolution(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Check if the kinematic resolutions are stored into this object (possibly specifying a label for them)
                    </comment>
                </method1>

                <method1 name="setKinResolution"
                         return="void"
                         args="['const pat::CandKinResolution&amp;','const std::string&amp;=&quot;&quot;']"
                         vars="['resol','label']"
                         qual="">
void setKinResolution(const pat::CandKinResolution&amp; resol, const std::string&amp; label=&quot;&quot;);
                    <comment>
          Add a kinematic resolution to this object (possibly with a label)
                    </comment>
                </method1>

                <method1 name="resolEta"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolEta(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on eta, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolTheta"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolTheta(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on theta, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPhi"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPhi(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on phi, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolE"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolE(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on energy, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolEt"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolEt(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on et, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolP"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolP(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on p, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPt"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPt(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on pt, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPInv"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPInv(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on 1/p, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPx"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPx(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on px, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPy"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPy(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on py, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolPz"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolPz(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Resolution on pz, possibly with a label to specify which resolution to use
                    </comment>
                </method1>

                <method1 name="resolM"
                         return="double"
                         args="['const std::string&amp;=&quot;&quot;']"
                         vars="['label']"
                         qual="const">
double resolM(const std::string&amp; label=&quot;&quot;) const;
                    <comment>
          Note: this will be zero if a mass-constrained parametrization is used for this object
                    </comment>
                </method1>

            </section>

            <typemap name="base_type"
                     value="ObjectType"
                     type="typedef"/>

        </class>
    </namespace>

    <type name="bool"/>
    <type name="const TriggerObjectStandAlone&amp;"/>
    <type name="const TriggerObjectStandAloneCollection"/>
    <type name="const TriggerObjectStandAloneCollection&amp;"/>
    <type name="const edm::Ptr&lt;ObjectType&gt;&amp;"/>
    <type name="const edm::Ptr&lt;pat::UserData&gt;&amp;"/>
    <type name="const edm::Ptr&lt;reco::Candidate&gt;&amp;"/>
    <type name="const edm::RefToBase&lt;ObjectType&gt;&amp;"/>
    <type name="const pat::CandKinResolution&amp;"/>
    <type name="const pat::LookupTableRecord&amp;"/>
    <type name="const pat::TriggerPrimitive&amp;"/>
    <type name="const reco::Candidate*"/>
    <type name="const reco::CandidatePtrVector&amp;"/>
    <type name="const reco::GenParticle&amp;"/>
    <type name="const reco::GenParticle*"/>
    <type name="const reco::GenParticleRef&amp;"/>
    <type name="const std::string&amp;"/>
    <type name="const std::vector&lt;TriggerPrimitive&gt;"/>
    <type name="const std::vector&lt;TriggerPrimitive&gt;&amp;"/>
    <type name="const std::vector&lt;pat::LookupTableRecord&gt;&amp;"/>
    <type name="const std::vector&lt;std::string&gt;&amp;"/>
    <type name="const unsigned"/>
    <type name="const void*"/>
    <type name="double"/>
    <type name="float"/>
    <type name="int"/>
    <type name="int32_t"/>
    <type name="pat::PATObject&lt;ObjectType&gt;"/>
    <type name="reco::GenParticleRef"/>
    <type name="size_t"/>
    <type name="std::vector&lt;reco::GenParticleRef&gt;"/>
    <type name="std::vector&lt;std::pair&lt;std::string, pat::LookupTableRecord&gt; &gt;"/>
    <type name="template&lt;typename T&gt; const T*"/>
    <type name="template&lt;typename T&gt; void"/>
    <type name="void"/>
</header>
