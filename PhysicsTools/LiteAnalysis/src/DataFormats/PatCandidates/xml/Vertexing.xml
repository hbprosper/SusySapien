<?xml version="1.0"?>
<!--
==============================================================================
  XML File: Vertexing.xml
  Created:  Fri Jan 15 20:47:22 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/PatCandidates/interface/Vertexing.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/PatCandidates/interface/Vertexing.h">

    <include name="&quot;DataFormats/VertexReco/interface/VertexFwd.h&quot;"/>
    <include name="&quot;DataFormats/VertexReco/interface/Vertex.h&quot;"/>
    <include name="&quot;DataFormats/TrackReco/interface/Track.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ptr.h&quot;"/>
    <include name="&quot;DataFormats/GeometryCommonDetAlgo/interface/Measurement1DFloat.h&quot;"/>
    <include name="&quot;DataFormats/GeometryCommonDetAlgo/interface/Measurement1D.h&quot;"/>

    <namespace name="pat">
        <comment>
  \class    pat::VertexAssociation VertexAssociation.h &quot;DataFormats/PatCandidates/interface/Vertexing.h&quot;
  \brief    Analysis-level structure for vertex-related information

  pat::VertexAssociation holds a reference to a vertex and extended information like the distance between the object and the vertex.

  For convenience, pat::VertexAssociation behaves like a VertexRef, that is (*assoc) is a reco::Vertex.

  The original proposal is at https://hypernews.cern.ch/HyperNews/CMS/get/physTools/587.html

  \author   Giovanni Petrucciani
  \version  $Id: Vertexing.h,v 1.1 2008/07/22 12:44:19 gpetrucc Exp $
        </comment>

        <class name="VertexAssociation"
               fullname="pat::VertexAssociation"
               module="DataFormats.PatCandidates"
               project=""
               type="regular">

            <section name="public">
                <constructor name="VertexAssociation"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
VertexAssociation();
                    <comment>
                Create a null vertx association
                    </comment>
                </constructor>

                <constructor name="VertexAssociation"
                             return=""
                             args="['const reco::VertexRef&amp;']"
                             vars="['vertex']"
                             qual="">
VertexAssociation(const reco::VertexRef&amp; vertex);
                    <comment>
                Create a vertex association given a ref to a vertex
                    </comment>
                </constructor>

                <constructor name="VertexAssociation"
                             return=""
                             args="['const reco::VertexRef&amp;','const reco::TrackBaseRef&amp;']"
                             vars="['vertex','tk']"
                             qual="">
VertexAssociation(const reco::VertexRef&amp; vertex, const reco::TrackBaseRef&amp; tk);
                    <comment>
                because it requires access to the magnetic field and other condition data.
                    </comment>
                </constructor>

                <method1 name="isNull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNull() const;
                    <comment>
               --- Methods to mimick VertexRef
                Return 'true' if this is a null association (that is, no vertex)
                    </comment>
                </method1>

                <method1 name="isNonnull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNonnull() const;
                    <comment>
                Return 'true' unless this is a null association (that is, no vertex)
                    </comment>
                </method1>

                <method1 name="isAvailable"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isAvailable() const;
                    <comment>
                Return 'true' if the reco::Vertex is available in the file, false if it has been dropped.
                    </comment>
                </method1>

                <operator name="operator*"
                          return="const reco::Vertex&amp;"
                          args="['void']"
                          vars="['']"
                          qual="const">
const reco::Vertex&amp; operator*() const;
                    <comment>
                Return the vertex (that is, you can do &quot;const reco::Vertex &amp;vtx = *assoc&quot;)
                    </comment>
                </operator>

                <operator name="operator-&gt;"
                          return="const reco::Vertex*"
                          args="['void']"
                          vars="['']"
                          qual="const">
const reco::Vertex* operator-&gt;() const;
                    <comment>
                Allows VertexAssociation to behave like a vertex ref  (e.g. to do &quot;assoc-&gt;position()&quot;)
                    </comment>
                </operator>

                <method1 name="vertexRef"
                         return="const reco::VertexRef&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const reco::VertexRef&amp; vertexRef() const;
                    <comment>
               --- Methods to get the Vertex and track
                Returns the reference to the vertex (can be a null reference)
                    </comment>
                </method1>

                <method1 name="vertex"
                         return="const reco::Vertex*"
                         args="['void']"
                         vars="['']"
                         qual="const">
const reco::Vertex* vertex() const;
                    <comment>
                Returns a pointer to the vertex, or a null pointer if there is no vertex (null association)
                    </comment>
                </method1>

                <method1 name="hasTrack"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasTrack() const;
                    <comment>
                Returns 'true' if a reference to a track was stored in this VertexAssociation
                    </comment>
                </method1>

                <method1 name="trackRef"
                         return="const reco::TrackBaseRef&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const reco::TrackBaseRef&amp; trackRef() const;
                    <comment>
                Returns a reference to the track stored in this vertex (can be null)
                    </comment>
                </method1>

                <method1 name="track"
                         return="const reco::Track*"
                         args="['void']"
                         vars="['']"
                         qual="const">
const reco::Track* track() const;
                    <comment>
                Returns a C++ pointer to the track stored in this vertex (can be a null pointer)
                    </comment>
                </method1>

                <method1 name="dz"
                         return="const Measurement1DFloat&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const Measurement1DFloat&amp; dz() const;
                    <comment>
                Note 1: if the BeamSpot was used as Vertex, the error includes the BeamSpot spread!
                    </comment>
                </method1>

                <method1 name="dr"
                         return="const Measurement1DFloat&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const Measurement1DFloat&amp; dr() const;
                    <comment>
                Distance between the object and the vertex in the transverse plane, and it's error.
                    </comment>
                </method1>

                <method1 name="hasTransverseIP"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasTransverseIP() const;
                    <comment>
                True if the transverse distance was computed for this VertexAssociation
                    </comment>
                </method1>

                <method1 name="hasErrors"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasErrors() const;
                    <comment>
                True if the errors on dr and dz have been set, false if they're nulls
                    </comment>
                </method1>

                <method1 name="setDz"
                         return="void"
                         args="['const Measurement1DFloat&amp;']"
                         vars="['dz']"
                         qual="">
void setDz(const Measurement1DFloat&amp; dz);
                    <comment>
               ---- Methods to set distances
                    </comment>
                </method1>

                <method1 name="setDr"
                         return="void"
                         args="['const Measurement1DFloat&amp;']"
                         vars="['dr']"
                         qual="">
void setDr(const Measurement1DFloat&amp; dr);
                </method1>

                <method1 name="setDz"
                         return="void"
                         args="['const Measurement1D&amp;']"
                         vars="['dz']"
                         qual="">
void setDz(const Measurement1D&amp; dz);
                </method1>

                <method1 name="setDr"
                         return="void"
                         args="['const Measurement1D&amp;']"
                         vars="['dr']"
                         qual="">
void setDr(const Measurement1D&amp; dr);
                </method1>

                <method1 name="setDistances"
                         return="void"
                         args="['const AlgebraicVector3&amp;','const AlgebraicSymMatrix33&amp;']"
                         vars="['dist','err']"
                         qual="">
void setDistances(const AlgebraicVector3&amp; dist, const AlgebraicSymMatrix33&amp; err);
                    <comment>
                Set dz and dr given the distance and the 3x3 total covariance matrix of the distance
                    </comment>
                </method1>

                <method2 name="setDistances"
                         return="template&lt;typename T1, typename T2&gt; void"
                         args="['const T1&amp;','const T2&amp;','const AlgebraicSymMatrix33&amp;']"
                         vars="['p1','p2','err']"
                         qual="">
template&lt;typename T1, typename T2&gt;             void setDistances(const T1&amp; p1, const T2&amp; p2, const AlgebraicSymMatrix33&amp; err);
                    <comment>
                'p1', 'p2' can be anything that has methods .x(), .y(), .z() (e.g. GlobalPoint, Vertex, ...)
                    </comment>
                </method2>

            </section>

        </class>
    </namespace>

    <type name="bool"/>
    <type name="const AlgebraicSymMatrix33&amp;"/>
    <type name="const AlgebraicVector3&amp;"/>
    <type name="const Measurement1D&amp;"/>
    <type name="const Measurement1DFloat&amp;"/>
    <type name="const reco::Track*"/>
    <type name="const reco::TrackBaseRef&amp;"/>
    <type name="const reco::Vertex&amp;"/>
    <type name="const reco::Vertex*"/>
    <type name="const reco::VertexRef&amp;"/>
    <type name="pat::VertexAssociation"/>
    <type name="template&lt;typename T1, typename T2&gt; void"/>
    <type name="void"/>
</header>
