<?xml version="1.0"?>
<!--
==============================================================================
  XML File: DetSetLazyVector.xml
  Created:  Thu Jan 14 22:45:57 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/DetSetLazyVector.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/DetSetLazyVector.h">

    <include name="&lt;algorithm&gt;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&quot;boost/concept_check.hpp&quot;"/>
    <include name="&quot;boost/iterator/transform_iterator.hpp&quot;"/>
    <include name="&quot;boost/shared_ptr.hpp&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/DetSet.h&quot;"/>
    <include name="&quot;FWCore/Utilities/interface/EDMException.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;T&gt; DetSetLazyVector"/>

        <namespace name="dslvdetail">
            <comment>
     Helper function, to regularize throwing of exceptions.
            </comment>
            <function1 name="_throw_range"
                       return="inline void"
                       args="['det_id_type']"
                       vars="['i']"
                       qual="">
inline     void _throw_range(det_id_type i);
                <comment>
       Throw an edm::Exception with an appropriate message
                </comment>
            </function1>

        </namespace>

        <namespace name="dslv">

            <class name="LazyGetter"
                   fullname="edm::dslv::LazyGetter&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="abstract template"
                   template="template&lt;typename T&gt;">

                <section name="public">
                    <destructor name="~LazyGetter"
                                return="virtual"
                                args="['void']"
                                vars="['']"
                                qual="">
virtual ~LazyGetter();
                    </destructor>

                    <method2 name="fill"
                             return="virtual void"
                             args="['DetSet&lt;T&gt;&amp;']"
                             vars="['']"
                             qual="= 0">
virtual void fill(DetSet&lt;T&gt;&amp;)=0;
                    </method2>

                </section>

            </class>

            <class name="LazyAdapter"
                   fullname="edm::dslv::LazyAdapter&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">
                <baseclass name="public std::unary_function&lt;const DetSet&lt;T&gt;&amp;, const DetSet&lt;T&gt;&amp;&gt;"/>

                <section>
                    <constructor name="LazyAdapter"
                                 return=""
                                 args="['boost::shared_ptr&lt;LazyGetter&lt;T&gt; &gt;']"
                                 vars="['iGetter']"
                                 qual="">
LazyAdapter(boost::shared_ptr&lt;LazyGetter&lt;T&gt; &gt; iGetter);
                    </constructor>

                    <operator name="operator()"
                              return="const DetSet&lt;T&gt;&amp;"
                              args="['const DetSet&lt;T&gt;&amp;']"
                              vars="['iUpdate']"
                              qual="const">
const DetSet&lt;T&gt;&amp; operatorPP(const DetSet&lt;T&gt;&amp; iUpdate) const;
                    </operator>

                </section>

            </class>
        </namespace>

        <namespace name="refhelper">

            <class name="FindDetSetForDetSetLazyVector"
                   fullname="edm::refhelper::FindDetSetForDetSetLazyVector&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">
                <baseclass name="public std::binary_function&lt;const DetSetLazyVector&lt;T&gt;&amp;, edm::det_id_type, const DetSet&lt;T&gt;*&gt;"/>

                <section>
                    <typedef name="self"
                             value="FindDetSetForDetSetLazyVector&lt;T&gt;">
typedef FindDetSetForDetSetLazyVector&lt;T&gt; self;
                    </typedef>

                    <operator name="operator()"
                              return="typename self::result_type"
                              args="['typename self::first_argument_type','typename self::second_argument_type']"
                              vars="['iContainer','iIndex']"
                              qual="const">
typename self::result_type operatorPP(typename self::first_argument_type iContainer, typename self::second_argument_type iIndex) const;
                    </operator>

                </section>

                <typemap name="self"
                         value="FindDetSetForDetSetLazyVector&lt;T&gt;"
                         type="typedef"/>

            </class>
        </namespace>

        <class name="DetSetLazyVector"
               fullname="edm::DetSetLazyVector&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <constructor name="BOOST_CLASS_REQUIRE"
                             return=""
                             args="['T','boost','LessThanComparableConcept']"
                             vars="['','','']"
                             qual="">
BOOST_CLASS_REQUIRE(T, boost, LessThanComparableConcept);
                    <comment>
        operator&lt;.
                    </comment>
                </constructor>

            </section>
            <section name="public">
                <typedef name="detset"
                         value="DetSet&lt;T&gt;">
typedef DetSet&lt;T&gt; detset;
                </typedef>

                <typedef name="value_type"
                         value="detset">
typedef detset value_type;
                </typedef>

                <typedef name="collection_type"
                         value="std::vector&lt;value_type&gt;">
typedef std::vector&lt;value_type&gt; collection_type;
                </typedef>

                <typedef name="const_reference"
                         value="detset const&amp;">
typedef detset const&amp; const_reference;
                </typedef>

                <typedef name="const_iterator"
                         value="boost::transform_iterator&lt;dslv::LazyAdapter&lt;T&gt;, typename collection_type::const_iterator &gt;">
typedef boost::transform_iterator&lt;dslv::LazyAdapter&lt;T&gt;, typename collection_type::const_iterator &gt; const_iterator;
                    <comment>
      iterator returns a DetSet&lt;T&gt; instead of a Ref&lt;...&gt;
                    </comment>
                </typedef>

                <typedef name="size_type"
                         value="typename collection_type::size_type">
typedef typename collection_type::size_type size_type;
                </typedef>

                <constructor name="DetSetLazyVector"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
DetSetLazyVector();
                    <comment>
       Add the following only if needed.
      template &lt;class InputIterator&gt;
      DetSetLazyVector(InputIterator b, InputIterator e);
                    </comment>
                </constructor>

                <constructor name="DetSetLazyVector"
                             return=""
                             args="['boost::shared_ptr&lt;dslv::LazyGetter&lt;T&gt; &gt;','const std::vector&lt;det_id_type&gt;&amp;']"
                             vars="['iGetter','iDets']"
                             qual="">
DetSetLazyVector(boost::shared_ptr&lt;dslv::LazyGetter&lt;T&gt; &gt; iGetter, const std::vector&lt;det_id_type&gt;&amp; iDets);
                </constructor>

                <method1 name="swap"
                         return="void"
                         args="['DetSetLazyVector&amp;']"
                         vars="['other']"
                         qual="">
void swap(DetSetLazyVector&amp; other);
                </method1>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                    <comment>
        Return true if we contain no DetSets.
                    </comment>
                </method1>

                <method1 name="size"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type size() const;
                    <comment>
        Return the number of contained DetSets
                    </comment>
                </method1>

                <method1 name="find"
                         return="const_iterator"
                         args="['det_id_type']"
                         vars="['id']"
                         qual="const">
const_iterator find(det_id_type id) const;
                    <comment>
        if there is no such DetSet.
                    </comment>
                </method1>

                <operator name="operator[]"
                          return="const_reference"
                          args="['det_id_type']"
                          vars="['i']"
                          qual="const">
const_reference operator[](det_id_type i) const;
                    <comment>
        **DO NOT MODIFY THE id DATA MEMBER OF THE REFERENCED DetSet!**
                    </comment>
                </operator>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                    <comment>
        Return an iterator to the first DetSet.
                    </comment>
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                    <comment>
        Return the off-the-end iterator.
                    </comment>
                </method1>

            </section>

            <typemap name="collection_type"
                     value="std::vector&lt;DetSet&lt;T&gt; &gt;"
                     type="typedef"/>
            <typemap name="const_iterator"
                     value="typename boost::transform_iterator&lt;dslv::LazyAdapter&lt;T&gt;, typename std::vector&lt;DetSet&lt;T&gt; &gt;::const_iterator &gt;"
                     type="typedef"/>
            <typemap name="const_reference"
                     value="DetSet&lt;T&gt; const&amp;"
                     type="typedef"/>
            <typemap name="detset"
                     value="DetSet&lt;T&gt;"
                     type="typedef"/>
            <typemap name="size_type"
                     value="typename std::vector&lt;DetSet&lt;T&gt; &gt;::size_type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="DetSet&lt;T&gt;"
                     type="typedef"/>

        </class>

        <namespace name="refhelper">
            <comment>
  specialize behavior of edm::Ref to get access to the 'Det'
            </comment>

            <class name="FindForDetSetLazyVector"
                   fullname="edm::refhelper::FindForDetSetLazyVector&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">
                <baseclass name="public std::binary_function&lt;const DetSetLazyVector&lt;T&gt;&amp;, std::pair&lt;det_id_type, typename DetSet&lt;T&gt;::collection_type::size_type&gt;, const T*&gt;"/>

                <section>
                    <typedef name="self"
                             value="FindForDetSetLazyVector&lt;T&gt;">
typedef FindForDetSetLazyVector&lt;T&gt; self;
                    </typedef>

                    <operator name="operator()"
                              return="typename self::result_type"
                              args="['typename self::first_argument_type','typename self::second_argument_type']"
                              vars="['iContainer','iIndex']"
                              qual="">
typename self::result_type operatorPP(typename self::first_argument_type iContainer, typename self::second_argument_type iIndex);
                    </operator>

                </section>

                <typemap name="self"
                         value="FindForDetSetLazyVector&lt;T&gt;"
                         type="typedef"/>

            </class>

            <class name="FindTrait&lt;DetSetLazyVector&lt;T&gt;,T&gt;"
                   fullname="edm::refhelper::FindTrait&lt;DetSetLazyVector&lt;T&gt;,T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <typedef name="value"
                             value="FindForDetSetLazyVector&lt;T&gt;">
typedef FindForDetSetLazyVector&lt;T&gt; value;
                    </typedef>

                </section>

                <typemap name="value"
                         value="FindForDetSetLazyVector&lt;T&gt;"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="DetSet&lt;T&gt;&amp;"/>
    <type name="DetSetLazyVector&amp;"/>
    <type name="LessThanComparableConcept"/>
    <type name="bool"/>
    <type name="boost"/>
    <type name="boost::shared_ptr&lt;LazyGetter&lt;T&gt; &gt;"/>
    <type name="boost::shared_ptr&lt;dslv::LazyGetter&lt;T&gt; &gt;"/>
    <type name="const DetSet&lt;T&gt;&amp;"/>
    <type name="const std::vector&lt;det_id_type&gt;&amp;"/>
    <type name="const_iterator"/>
    <type name="const_reference"/>
    <type name="det_id_type"/>
    <type name="edm::DetSetLazyVector&lt;T&gt;"/>
    <type name="edm::dslv::LazyAdapter&lt;T&gt;"/>
    <type name="edm::dslv::LazyGetter&lt;T&gt;"/>
    <type name="edm::refhelper::FindDetSetForDetSetLazyVector&lt;T&gt;"/>
    <type name="edm::refhelper::FindForDetSetLazyVector&lt;T&gt;"/>
    <type name="edm::refhelper::FindTrait&lt;DetSetLazyVector&lt;T&gt;, T&gt;"/>
    <type name="size_type"/>
    <type name="std::binary_function&lt;const DetSetLazyVector&lt;T&gt;&amp;, edm::det_id_type, const DetSet&lt;T&gt;*&gt;"/>
    <type name="std::binary_function&lt;const DetSetLazyVector&lt;T&gt;&amp;, std::pair&lt;det_id_type, typename DetSet&lt;T&gt;::collection_type::size_type&gt;, const T*&gt;"/>
    <type name="std::unary_function&lt;const DetSet&lt;T&gt;&amp;, const DetSet&lt;T&gt;&amp;&gt;"/>
    <type name="typename self::first_argument_type"/>
    <type name="typename self::result_type"/>
    <type name="typename self::second_argument_type"/>
    <type name="void"/>
</header>
