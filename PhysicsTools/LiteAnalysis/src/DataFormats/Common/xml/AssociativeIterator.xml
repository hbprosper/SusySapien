<?xml version="1.0"?>
<!--
==============================================================================
  XML File: AssociativeIterator.xml
  Created:  Fri Jan 15 20:45:21 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/AssociativeIterator.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/AssociativeIterator.h">

    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&lt;DataFormats/Common/interface/EDProductGetter.h&gt;"/>

    <namespace name="edm">
    </namespace>

    <namespace name="edm">

        <namespace name="helper">
            <comment>
       Helper classes to convert one ref type to another.
       Now it's able to convert anything to itself, and RefToBase to anything else
       This won't be needed if we used Ptr
            </comment>

            <class name="RefConverter"
                   fullname="edm::helper::RefConverter&lt;RefFrom, RefTo&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename RefFrom, typename RefTo&gt;">

                <section>
                    <method1 name="convert"
                             return="static RefTo"
                             args="['const RefFrom&amp;']"
                             vars="['ref']"
                             qual="">
static RefTo convert(const RefFrom&amp; ref);
                    </method1>

                </section>

            </class>

            <class name="RefConverter&lt;RefToBase&lt;T&gt;, Ptr&lt;T&gt; &gt;"
                   fullname="edm::helper::RefConverter&lt;RefToBase&lt;T&gt;, Ptr&lt;T&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="convert"
                             return="static Ptr&lt;T&gt;"
                             args="['const RefToBase&lt;T&gt;&amp;']"
                             vars="['ref']"
                             qual="">
static Ptr&lt;T&gt; convert(const RefToBase&lt;T&gt;&amp; ref);
                    </method2>

                </section>

            </class>

            <class name="RefConverter&lt;RefToBase&lt;T&gt;, Ref&lt;C,V,F&gt; &gt;"
                   fullname="edm::helper::RefConverter&lt;RefToBase&lt;T&gt;, Ref&lt;C,V,F&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T, typename C, typename V, typename F&gt;">

                <section>
                    <method2 name="convert"
                             return="static Ref&lt;C, V, F&gt;"
                             args="['const RefToBase&lt;T&gt;&amp;']"
                             vars="['ref']"
                             qual="">
static Ref&lt;C, V, F&gt; convert(const RefToBase&lt;T&gt;&amp; ref);
                    </method2>

                </section>

            </class>
        </namespace>

        <class name="EdmEventItemGetter"
               fullname="edm::EdmEventItemGetter&lt;RefType&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename RefType&gt;">
            <comment>
        the implementation uses View, and works for RefType = Ref, RefToBase and Ptr
            </comment>

            <section name="public">
                <typedef name="element_type"
                         value="typename RefType::value_type">
typedef typename RefType::value_type element_type;
                </typedef>

                <constructor name="EdmEventItemGetter"
                             return=""
                             args="['const edm::Event&amp;']"
                             vars="['iEvent']"
                             qual="">
EdmEventItemGetter(const edm::Event&amp; iEvent);
                </constructor>

                <destructor name="~EdmEventItemGetter"
                            return=""
                            args="['void']"
                            vars="['']"
                            qual="">
~EdmEventItemGetter();
                </destructor>

                <method1 name="get"
                         return="RefType"
                         args="['const ProductID&amp;','size_t']"
                         vars="['id','idx']"
                         qual="const">
RefType get(const ProductID&amp; id, size_t idx) const;
                </method1>

            </section>
            <section name="private">
                <constant name="iEvent_"
                          type="const edm::Event&amp;amp;"
                          value=""/>
            </section>

            <typemap name="element_type"
                     value="typename RefType::value_type"
                     type="typedef"/>

        </class>

        <namespace name="helper">
            <comment>
       unfortunately it's not possible to define value_type of an Association&lt;C&gt; correctly
       so we need yet another template trick
            </comment>

            <class name="AssociativeCollectionValueType"
                   fullname="edm::helper::AssociativeCollectionValueType&lt;AC&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename AC&gt;">

                <section>
                    <typedef name="type"
                             value="typename AC::value_type">
typedef typename AC::value_type type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="typename AC::value_type"
                         type="typedef"/>

            </class>

            <class name="AssociativeCollectionValueType&lt; Association&lt;C&gt; &gt;"
                   fullname="edm::helper::AssociativeCollectionValueType&lt; Association&lt;C&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename C&gt;">

                <section>
                    <typedef name="type"
                             value="typename Association&lt;C&gt;::reference_type">
typedef typename Association&lt;C&gt;::reference_type type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="typename Association&lt;C&gt;::reference_type"
                         type="typedef"/>

            </class>
        </namespace>

        <class name="AssociativeIterator"
               fullname="edm::AssociativeIterator&lt;KeyRefType, AssociativeCollection, ItemGetter&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename KeyRefType, typename AssociativeCollection, typename ItemGetter=EdmEventItemGetter&lt;KeyRefType&gt; &gt;">

            <section name="public">
                <typedef name="key_type"
                         value="KeyRefType">
typedef KeyRefType key_type;
                </typedef>

                <typedef name="key_val_type"
                         value="typename KeyRefType::value_type">
typedef typename KeyRefType::value_type key_val_type;
                </typedef>

                <typedef name="val_type"
                         value="typename helper::AssociativeCollectionValueType&lt;AssociativeCollection&gt;::type">
typedef typename helper::AssociativeCollectionValueType&lt;AssociativeCollection&gt;::type val_type;
                </typedef>

                <typedef name="value_type"
                         value="typename std::pair&lt;key_type, val_type&gt;">
typedef typename std::pair&lt;key_type, val_type&gt; value_type;
                </typedef>

                <typedef name="self_type"
                         value="AssociativeIterator&lt;KeyRefType, AssociativeCollection, ItemGetter&gt;">
typedef AssociativeIterator&lt;KeyRefType, AssociativeCollection, ItemGetter&gt; self_type;
                </typedef>

                <constructor name="AssociativeIterator"
                             return=""
                             args="['const AssociativeCollection&amp;','const ItemGetter&amp;']"
                             vars="['map','getter']"
                             qual="">
AssociativeIterator(const AssociativeCollection&amp; map, const ItemGetter&amp; getter);
                    <comment>
            Create the associative iterator, pointing at the beginning of the collection
                    </comment>
                </constructor>

                <operator name="operator++"
                          return="self_type&amp;"
                          args="['void']"
                          vars="['']"
                          qual="">
self_type&amp; operator++();
                </operator>

                <operator name="operator--"
                          return="self_type&amp;"
                          args="['void']"
                          vars="['']"
                          qual="">
self_type&amp; operator--();
                </operator>

                <method1 name="nextProductID"
                         return="self_type&amp;"
                         args="['void']"
                         vars="['']"
                         qual="">
self_type&amp; nextProductID();
                </method1>

                <operator name="operator*"
                          return="const value_type&amp;"
                          args="['void']"
                          vars="['']"
                          qual="const">
const value_type&amp; operator*() const;
                    <comment>
           self_type &amp; skipTo(const ProductID &amp;id, size_t offs = 0) ; // to be implemented one day
                    </comment>
                </operator>

                <operator name="operator-&gt;"
                          return="const value_type*"
                          args="['void']"
                          vars="['']"
                          qual="const">
const value_type* operator-&gt;() const;
                </operator>

                <method1 name="get"
                         return="const value_type*"
                         args="['void']"
                         vars="['']"
                         qual="const">
const value_type* get() const;
                </method1>

                <method1 name="key"
                         return="const key_type&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const key_type&amp; key() const;
                </method1>

                <method1 name="val"
                         return="const val_type&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const val_type&amp; val() const;
                </method1>

                <method1 name="id"
                         return="const ProductID&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const ProductID&amp; id() const;
                </method1>

                <operator name="operator bool"
                          return=""
                          args="['void']"
                          vars="['']"
                          qual="const">
operator bool() const;
                </operator>

                <method1 name="end"
                         return="self_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
self_type end() const;
                </method1>

                <operator name="operator=="
                          return="bool"
                          args="['const self_type&amp;']"
                          vars="['other']"
                          qual="const">
bool operator==(const self_type&amp; other) const;
                </operator>

                <operator name="operator!="
                          return="bool"
                          args="['const self_type&amp;']"
                          vars="['other']"
                          qual="const">
bool operator!=(const self_type&amp; other) const;
                </operator>

                <operator name="operator&lt;"
                          return="bool"
                          args="['const self_type&amp;']"
                          vars="['other']"
                          qual="const">
bool operator&lt;(const self_type&amp; other) const;
                </operator>

            </section>
            <section name="private">
                <constant name="map_"
                          type="const AssociativeCollection&amp;amp;"
                          value=""/>
            </section>

            <typemap name="key_type"
                     value="KeyRefType"
                     type="typedef"/>
            <typemap name="key_val_type"
                     value="typename KeyRefType::typename std::pair&lt;KeyRefType, typename helper::AssociativeCollectionValueType&lt;AssociativeCollection&gt;::type&gt;"
                     type="typedef"/>
            <typemap name="self_type"
                     value="AssociativeIterator&lt;KeyRefType, AssociativeCollection, ItemGetter&gt;"
                     type="typedef"/>
            <typemap name="val_type"
                     value="typename helper::AssociativeCollectionValueType&lt;AssociativeCollection&gt;::type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="typename std::pair&lt;KeyRefType, typename helper::AssociativeCollectionValueType&lt;AssociativeCollection&gt;::type&gt;"
                     type="typedef"/>

        </class>
    </namespace>

    <type name="Ptr&lt;T&gt;"/>
    <type name="Ref&lt;C, V, F&gt;"/>
    <type name="bool"/>
    <type name="const ProductID&amp;"/>
    <type name="const RefToBase&lt;T&gt;&amp;"/>
    <type name="const edm::Event&amp;"/>
    <type name="const key_type&amp;"/>
    <type name="const self_type&amp;"/>
    <type name="const val_type&amp;"/>
    <type name="const value_type&amp;"/>
    <type name="const value_type*"/>
    <type name="edm::AssociativeIterator&lt;KeyRefType, AssociativeCollection, ItemGetter&gt;"/>
    <type name="edm::EdmEventItemGetter&lt;RefType&gt;"/>
    <type name="edm::helper::AssociativeCollectionValueType&lt;AC&gt;"/>
    <type name="edm::helper::AssociativeCollectionValueType&lt;Association&lt;C&gt; &gt;"/>
    <type name="edm::helper::RefConverter&lt;RefFrom, RefTo&gt;"/>
    <type name="edm::helper::RefConverter&lt;RefToBase&lt;T&gt;, Ptr&lt;T&gt; &gt;"/>
    <type name="edm::helper::RefConverter&lt;RefToBase&lt;T&gt;, Ref&lt;C, V, F&gt; &gt;"/>
    <type name="self_type"/>
    <type name="self_type&amp;"/>
    <type name="size_t"/>
    <type name="void"/>
</header>
