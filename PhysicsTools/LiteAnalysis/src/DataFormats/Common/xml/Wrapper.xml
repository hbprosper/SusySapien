<?xml version="1.0"?>
<!--
==============================================================================
  XML File: Wrapper.xml
  Created:  Thu Jan 14 22:46:32 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/Wrapper.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/Wrapper.h">

    <include name="&lt;algorithm&gt;"/>
    <include name="&lt;memory&gt;"/>
    <include name="&lt;string&gt;"/>
    <include name="&lt;typeinfo&gt;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&lt;list&gt;"/>
    <include name="&lt;deque&gt;"/>
    <include name="&lt;set&gt;"/>
    <include name="&quot;boost/mpl/if.hpp&quot;"/>
    <include name="&quot;DataFormats/Common/interface/EDProduct.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorHolder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;FWCore/Utilities/interface/EDMException.h&quot;"/>

    <namespace name="edm">

        <class name="Wrapper"
               fullname="edm::Wrapper&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template privatecopyctor"
               template="template&lt;class T&gt;">
            <baseclass name="public EDProduct"/>

            <section name="public">
                <typedef name="value_type"
                         value="T">
typedef T value_type;
                </typedef>

                <typedef name="wrapped_type"
                         value="T">
typedef T wrapped_type;
                </typedef>

                <constructor name="Wrapper"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
Wrapper();
                </constructor>

                <constructor name="Wrapper"
                             return="explicit"
                             args="['std::auto_ptr&lt;T&gt;']"
                             vars="['ptr']"
                             qual="">
explicit Wrapper(std::auto_ptr&lt;T&gt; ptr);
                </constructor>

                <destructor name="~Wrapper"
                            return="virtual"
                            args="['void']"
                            vars="['']"
                            qual="">
virtual ~Wrapper();
                </destructor>

                <method1 name="product"
                         return="T const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
T const* product() const;
                </method1>

                <operator name="operator-&gt;"
                          return="T const*"
                          args="['void']"
                          vars="['']"
                          qual="const">
T const* operator-&gt;() const;
                </operator>

                <method1 name="productTypeInfo"
                         return="static const std::type_info&amp;"
                         args="['void']"
                         vars="['']"
                         qual="">
static const std::type_info&amp; productTypeInfo();
                    <comment>
      these are used by FWLite
                    </comment>
                </method1>

                <method1 name="typeInfo"
                         return="static const std::type_info&amp;"
                         args="['void']"
                         vars="['']"
                         qual="">
static const std::type_info&amp; typeInfo();
                </method1>

                <constructor name="Wrapper"
                             return=""
                             args="['T*']"
                             vars="['']"
                             qual="">
Wrapper(T*);
                    <comment>
       REFLEX must call the following constructor
        the constructor takes ownership of T*
                    </comment>
                </constructor>

            </section>

            <typemap name="value_type"
                     value="T"
                     type="typedef"/>
            <typemap name="wrapped_type"
                     value="T"
                     type="typedef"/>

        </class>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>

    <namespace name="edm">

        <class name="DoFillView"
               fullname="edm::DoFillView&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector_ptr&amp;']"
                          vars="['obj','id','pointers','helpers']"
                          qual="const">
void operatorPP(T const&amp; obj, ProductID const&amp; id, std::vector&lt;void const*&gt;&amp; pointers, helper_vector_ptr&amp; helpers) const;
                </operator>

            </section>

        </class>

        <class name="DoNotFillView"
               fullname="edm::DoNotFillView&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector_ptr&amp;']"
                          vars="['','','','']"
                          qual="const">
void operatorPP(T const&amp;, ProductID const&amp;, std::vector&lt;void const*&gt;&amp;, helper_vector_ptr&amp;) const;
                </operator>

            </section>

        </class>

        <class name="DoSetPtr"
               fullname="edm::DoSetPtr&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','const std::type_info&amp;','unsigned long','void const*&amp;']"
                          vars="['obj','iToType','iIndex','oPtr']"
                          qual="const">
void operatorPP(T const&amp; obj, const std::type_info&amp; iToType, unsigned long iIndex, void const*&amp; oPtr) const;
                </operator>

                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','const std::type_info&amp;','const std::vector&lt;unsigned long&gt;&amp;','std::vector&lt;void const*&gt;&amp;']"
                          vars="['obj','iToType','iIndex','oPtr']"
                          qual="const">
void operatorPP(T const&amp; obj, const std::type_info&amp; iToType, const std::vector&lt;unsigned long&gt;&amp; iIndex, std::vector&lt;void const*&gt;&amp; oPtr) const;
                </operator>

            </section>

        </class>

        <class name="DoNotSetPtr"
               fullname="edm::DoNotSetPtr&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','const std::type_info&amp;','unsigned long','void const*&amp;']"
                          vars="['','','','oPtr']"
                          qual="const">
void operatorPP(T const&amp;, const std::type_info&amp;, unsigned long, void const*&amp; oPtr) const;
                </operator>

                <operator name="operator()"
                          return="void"
                          args="['T const&amp;','const std::type_info&amp;','const std::vector&lt;unsigned long&gt;&amp;','std::vector&lt;void const*&gt;&amp;']"
                          vars="['obj','iToType','iIndex','oPtr']"
                          qual="const">
void operatorPP(T const&amp; obj, const std::type_info&amp; iToType, const std::vector&lt;unsigned long&gt;&amp; iIndex, std::vector&lt;void const*&gt;&amp; oPtr) const;
                </operator>

            </section>

        </class>

        <class name="DoSwap"
               fullname="edm::DoSwap&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">
            <comment>
     This is an attempt to optimize for speed, by avoiding the copying
     of large objects of type T. In this initial version, we assume
     that for any class having a 'swap' member function should call
     'swap' rather than copying the object.
            </comment>

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
void operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <class name="DoAssign"
               fullname="edm::DoAssign&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="void"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
void operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <class name="IsMergeable"
               fullname="edm::IsMergeable&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;']"
                          vars="['a']"
                          qual="">
bool operatorPP(T&amp; a);
                </operator>

            </section>

        </class>

        <class name="IsNotMergeable"
               fullname="edm::IsNotMergeable&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;']"
                          vars="['a']"
                          qual="">
bool operatorPP(T&amp; a);
                </operator>

            </section>

        </class>

        <class name="DoMergeProduct"
               fullname="edm::DoMergeProduct&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
bool operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <class name="DoNotMergeProduct"
               fullname="edm::DoNotMergeProduct&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
bool operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <class name="DoHasIsProductEqual"
               fullname="edm::DoHasIsProductEqual&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;']"
                          vars="['a']"
                          qual="">
bool operatorPP(T&amp; a);
                </operator>

            </section>

        </class>

        <class name="DoNotHasIsProductEqual"
               fullname="edm::DoNotHasIsProductEqual&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;']"
                          vars="['a']"
                          qual="">
bool operatorPP(T&amp; a);
                </operator>

            </section>

        </class>

        <class name="DoIsProductEqual"
               fullname="edm::DoIsProductEqual&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
bool operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <class name="DoNotIsProductEqual"
               fullname="edm::DoNotIsProductEqual&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T&gt;">

            <section>
                <operator name="operator()"
                          return="bool"
                          args="['T&amp;','T&amp;']"
                          vars="['a','b']"
                          qual="">
bool operatorPP(T&amp; a, T&amp; b);
                </operator>

            </section>

        </class>

        <namespace name="detail">
            <comment>
     Metafunction support for compile-time selection of code used in
     Wrapper constructor
            </comment>
            <typedef name="(&amp; no_tag)[1]"
                     value="char">
typedef char (&amp; no_tag)[1];
            </typedef>

            <typedef name="(&amp; yes_tag)[2]"
                     value="char">
typedef char (&amp; yes_tag)[2];
            </typedef>

            <function2 name="void"
                       return="template&lt;typename T,"
                       args="['T::*) (T&amp;']"
                       vars="['']"
                       qual="&gt; struct swap_function">
template&lt;typename T, void (T::*)(T&amp;)&gt; struct swap_function;
                <comment>
       Definitions for the following struct and function templates are
       not needed; we only require the declarations.
                </comment>
            </function2>


            <class name="has_swap_function"
                   fullname="edm::detail::has_swap_function&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="sizeof"
                             return="static bool const value="
                             args="['has_swap_helper&lt;T&gt;== sizeof(yes_tag']"
                             vars="['(0))']"
                             qual="">
static bool const value=  sizeof(has_swap_helper&lt;T&gt;(0))== sizeof(yes_tag);
                    </method2>

                </section>

            </class>
            <function2 name="bool"
                       return="template&lt;typename T,"
                       args="['T::*) (T const &amp;']"
                       vars="['']"
                       qual="&gt; struct mergeProduct_function">
template&lt;typename T, bool (T::*)(T const&amp;)&gt; struct mergeProduct_function;
            </function2>


            <class name="has_mergeProduct_function"
                   fullname="edm::detail::has_mergeProduct_function&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="sizeof"
                             return="static bool const value="
                             args="['has_mergeProduct_helper&lt;T&gt;== sizeof(yes_tag']"
                             vars="['(0))']"
                             qual="">
static bool const value=  sizeof(has_mergeProduct_helper&lt;T&gt;(0))== sizeof(yes_tag);
                    </method2>

                </section>

            </class>
            <function2 name="bool"
                       return="template&lt;typename T,"
                       args="['T::*) (T const &amp;']"
                       vars="['']"
                       qual="&gt; struct isProductEqual_function">
template&lt;typename T, bool (T::*)(T const&amp;)&gt; struct isProductEqual_function;
            </function2>


            <class name="has_isProductEqual_function"
                   fullname="edm::detail::has_isProductEqual_function&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="sizeof"
                             return="static bool const value="
                             args="['has_isProductEqual_helper&lt;T&gt;== sizeof(yes_tag']"
                             vars="['(0))']"
                             qual="">
static bool const value=  sizeof(has_isProductEqual_helper&lt;T&gt;(0))== sizeof(yes_tag);
                    </method2>

                </section>

            </class>
        </namespace>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/RefVector.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefToBaseVector.h&quot;"/>

    <namespace name="edm">

        <namespace name="helpers">

            <class name="ViewFiller"
                   fullname="edm::helpers::ViewFiller&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="fill"
                             return="static void"
                             args="['T const&amp;','ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector_ptr&amp;']"
                             vars="['obj','id','pointers','helpers']"
                             qual="">
static void fill(T const&amp; obj, ProductID const&amp; id, std::vector&lt;void const*&gt;&amp; pointers, helper_vector_ptr&amp; helpers);
                    </method2>

                </section>

            </class>

            <class name="ViewFiller&lt;RefToBaseVector&lt;T&gt; &gt;"
                   fullname="edm::helpers::ViewFiller&lt;RefToBaseVector&lt;T&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="fill"
                             return="static void"
                             args="['RefToBaseVector&lt;T&gt; const&amp;','ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector_ptr&amp;']"
                             vars="['obj','id','pointers','helpers']"
                             qual="">
static void fill(RefToBaseVector&lt;T&gt; const&amp; obj, ProductID const&amp; id, std::vector&lt;void const*&gt;&amp; pointers, helper_vector_ptr&amp; helpers);
                    </method2>

                </section>

            </class>

            <class name="PtrSetter"
                   fullname="edm::helpers::PtrSetter&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method1 name="set"
                             return="static void"
                             args="['T const&amp;','const std::type_info&amp;','unsigned long','void const*&amp;']"
                             vars="['obj','iToType','iIndex','oPtr']"
                             qual="">
static void set(T const&amp; obj, const std::type_info&amp; iToType, unsigned long iIndex, void const*&amp; oPtr);
                    </method1>

                    <method2 name="fill"
                             return="static void"
                             args="['T const&amp;','const std::type_info&amp;','const std::vector&lt;unsigned long&gt;&amp;','std::vector&lt;void const*&gt;&amp;']"
                             vars="['obj','iToType','iIndex','oPtr']"
                             qual="">
static void fill(T const&amp; obj, const std::type_info&amp; iToType, const std::vector&lt;unsigned long&gt;&amp; iIndex, std::vector&lt;void const*&gt;&amp; oPtr);
                    </method2>

                </section>

            </class>
        </namespace>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/FillView.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/setPtr.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/fillPtrVector.h&quot;"/>

    <type name="&amp;"/>
    <type name="EDProduct"/>
    <type name="ProductID const&amp;"/>
    <type name="RefToBaseVector&lt;T&gt; const&amp;"/>
    <type name="bool"/>
    <type name="bool const value"/>
    <type name="const std::type_info&amp;"/>
    <type name="const std::vector&lt;unsigned long&gt;&amp;"/>
    <type name="edm::DoAssign&lt;T&gt;"/>
    <type name="edm::DoFillView&lt;T&gt;"/>
    <type name="edm::DoHasIsProductEqual&lt;T&gt;"/>
    <type name="edm::DoIsProductEqual&lt;T&gt;"/>
    <type name="edm::DoMergeProduct&lt;T&gt;"/>
    <type name="edm::DoNotFillView&lt;T&gt;"/>
    <type name="edm::DoNotHasIsProductEqual&lt;T&gt;"/>
    <type name="edm::DoNotIsProductEqual&lt;T&gt;"/>
    <type name="edm::DoNotMergeProduct&lt;T&gt;"/>
    <type name="edm::DoNotSetPtr&lt;T&gt;"/>
    <type name="edm::DoSetPtr&lt;T&gt;"/>
    <type name="edm::DoSwap&lt;T&gt;"/>
    <type name="edm::IsMergeable&lt;T&gt;"/>
    <type name="edm::IsNotMergeable&lt;T&gt;"/>
    <type name="edm::Wrapper&lt;T&gt;"/>
    <type name="edm::detail::has_isProductEqual_function&lt;T&gt;"/>
    <type name="edm::detail::has_mergeProduct_function&lt;T&gt;"/>
    <type name="edm::detail::has_swap_function&lt;T&gt;"/>
    <type name="edm::helpers::PtrSetter&lt;T&gt;"/>
    <type name="edm::helpers::ViewFiller&lt;RefToBaseVector&lt;T&gt; &gt;"/>
    <type name="edm::helpers::ViewFiller&lt;T&gt;"/>
    <type name="has_isProductEqual_helper&lt;T&gt;"/>
    <type name="has_mergeProduct_helper&lt;T&gt;"/>
    <type name="has_swap_helper&lt;T&gt;"/>
    <type name="helper_vector_ptr&amp;"/>
    <type name="std::auto_ptr&lt;T&gt;"/>
    <type name="std::vector&lt;void const*&gt;&amp;"/>
    <type name="unsigned long"/>
    <type name="void"/>
    <type name="void const*&amp;"/>
</header>
