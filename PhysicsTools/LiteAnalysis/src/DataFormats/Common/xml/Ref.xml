<?xml version="1.0"?>
<!--
==============================================================================
  XML File: Ref.xml
  Created:  Fri Jan 15 20:45:48 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/Ref.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/Ref.h">

    <include name="&quot;boost/functional.hpp&quot;"/>
    <include name="&quot;boost/call_traits.hpp&quot;"/>
    <include name="&quot;boost/type_traits.hpp&quot;"/>
    <include name="&quot;boost/mpl/has_xxx.hpp&quot;"/>
    <include name="&quot;boost/utility/enable_if.hpp&quot;"/>
    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/EDProductGetter.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/EDProductfwd.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefBase.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Handle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OrphanHandle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/TestHandle.h&quot;"/>
    <function2 name="compare_key"
               return="typename boost::enable_if&lt;has_key_compare&lt;C&gt;, bool&gt;::type"
               args="['K const&amp;','K const&amp;']"
               vars="['lhs','rhs']"
               qual="">
typename boost::enable_if&lt;has_key_compare&lt;C&gt;, bool&gt;::type   compare_key(K const&amp; lhs, K const&amp; rhs);
    </function2>

    <include name="&quot;DataFormats/Common/interface/RefTraits.h&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;typename C, typename T, typename F&gt;
  RefVector"/>
        <forward name="template&lt;typename T&gt;
  RefToBaseVector"/>

        <class name="Ref"
               fullname="edm::Ref&lt;C, T, F&gt;"
               module="DataFormats.Common"
               project=""
               type="template privatector"
               template="template&lt;typename C, typename T=typename refhelper::ValueTrait&lt;C&gt;::value, typename F=typename refhelper::FindTrait&lt;C, T&gt;::value&gt;">

            <section name="public">
                <typedef name="product_type"
                         value="C">
typedef C product_type;
                    <comment>
        for export
                    </comment>
                </typedef>

                <typedef name="value_type"
                         value="T">
typedef T value_type;
                </typedef>

                <typedef name="element_type"
                         value="T const">
typedef T const element_type;
                </typedef>

                <typedef name="finder_type"
                         value="F">
typedef F finder_type;
                </typedef>

                <typedef name="argument_type"
                         value="typename boost::binary_traits&lt;F&gt;::second_argument_type">
typedef typename boost::binary_traits&lt;F&gt;::second_argument_type argument_type;
                </typedef>

                <typedef name="key_type"
                         value="typename boost::remove_cv&lt;typename boost::remove_reference&lt;argument_type&gt;::type&gt;::type">
typedef typename boost::remove_cv&lt;typename boost::remove_reference&lt;argument_type&gt;::type&gt;::type key_type;
                </typedef>

                <constructor name="Ref"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
Ref();
                    <comment>
        Default constructor needed for reading from persistent store. Not for direct use.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['Handle&lt;C&gt; const&amp;','key_type','bool=true']"
                             vars="['handle','itemKey','setNow']"
                             qual="">
Ref(Handle&lt;C&gt; const&amp; handle, key_type itemKey, bool setNow=true);
                    <comment>
        General purpose constructor from handle.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['OrphanHandle&lt;C&gt; const&amp;','key_type','bool=true']"
                             vars="['handle','itemKey','setNow']"
                             qual="">
Ref(OrphanHandle&lt;C&gt; const&amp; handle, key_type itemKey, bool setNow=true);
                    <comment>
        General purpose constructor from orphan handle.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['RefVector&lt;C, T, F&gt; const&amp;','key_type','bool=true']"
                             vars="['refvector','itemKey','setNow']"
                             qual="">
Ref(RefVector&lt;C, T, F&gt; const&amp; refvector, key_type itemKey, bool setNow=true);
                    <comment>
        Note. refvector[index] returns a Ref where index is the index into
        the RefVector. This index argument is the index into the COLLECTION,
        not the index into the RefVector.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['C const*','key_type','bool=true']"
                             vars="['product','itemKey','setNow']"
                             qual="">
Ref(C const* product, key_type itemKey, bool setNow=true);
                    <comment>
        An exception will be thrown if an attempt is made to persistify
        any object containing this Ref.  Also, in the future work will
        be done to throw an exception if an attempt is made to put any object
        containing this Ref into an event(or run or lumi).
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['TestHandle&lt;C&gt; const&amp;','key_type','bool=true']"
                             vars="['handle','itemKey','setNow']"
                             qual="">
Ref(TestHandle&lt;C&gt; const&amp; handle, key_type itemKey, bool setNow=true);
                    <comment>
        An exception will be thrown if an attempt is made to persistify
        any object containing this Ref.  Also, in the future work will
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['ProductID const&amp;','key_type','EDProductGetter const*']"
                             vars="['productID','itemKey','prodGetter']"
                             qual="">
Ref(ProductID const&amp; productID, key_type itemKey, EDProductGetter const* prodGetter);
                    <comment>
        prodGetter will ususally be a pointer to the event principal.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['ProductID const&amp;','T const*','key_type','C const*']"
                             vars="['productID','item','item_key','product']"
                             qual="">
Ref(ProductID const&amp; productID, T const* item, key_type item_key, C const* product);
                    <comment>
        It is an error (not diagnosable at compile- or run-time) to call
        this constructor with a pointer to a T unless the pointed-to T
        object is already in a collection of type C stored in the
        Event. The given ProductID must be the id of the collection in
        the Event.
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return="explicit"
                             args="['ProductID const&amp;']"
                             vars="['id']"
                             qual="">
explicit Ref(ProductID const&amp; id);
                    <comment>
        ProductID).
                    </comment>
                </constructor>

                <constructor name="Ref"
                             return=""
                             args="['RefProd&lt;C&gt; const&amp;','key_type']"
                             vars="['refProd','itemKey']"
                             qual="">
Ref(RefProd&lt;C&gt; const&amp; refProd, key_type itemKey);
                    <comment>
        Constructor from RefProd&lt;C&gt; and key
                    </comment>
                </constructor>

                <destructor name="~Ref"
                            return=""
                            args="['void']"
                            vars="['']"
                            qual="">
~Ref();
                    <comment>
        Destructor
                    </comment>
                </destructor>

                <operator name="operator*"
                          return="T const&amp;"
                          args="['void']"
                          vars="['']"
                          qual="const">
T const&amp;     operator*() const;
                    <comment>
        Dereference operator
                    </comment>
                </operator>

                <operator name="operator-&gt;"
                          return="T const*"
                          args="['void']"
                          vars="['']"
                          qual="const">
T const*     operator-&gt;() const;
                    <comment>
        Member dereference operator
                    </comment>
                </operator>

                <method1 name="get"
                         return="T const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
T const* get() const;
                    <comment>
        Returns C++ pointer to the item
                    </comment>
                </method1>

                <method1 name="isNull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNull() const;
                    <comment>
        Checks for null
                    </comment>
                </method1>

                <method1 name="isNonnull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNonnull() const;
                    <comment>
      bool isNonnull() const {return id().isValid(); }
                    </comment>
                </method1>

                <operator name="operator!"
                          return="bool"
                          args="['void']"
                          vars="['']"
                          qual="const">
bool operator!() const;
                    <comment>
        Checks for null
                    </comment>
                </operator>

                <method1 name="id"
                         return="ProductID"
                         args="['void']"
                         vars="['']"
                         qual="const">
ProductID id() const;
                    <comment>
        Accessor for product ID.
                    </comment>
                </method1>

                <method1 name="productGetter"
                         return="EDProductGetter const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
EDProductGetter const* productGetter() const;
                    <comment>
        Accessor for product getter.
                    </comment>
                </method1>

                <method1 name="product"
                         return="C const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
C const* product() const;
                    <comment>
       Accessor must get the product if necessary
                    </comment>
                </method1>

                <method1 name="key"
                         return="key_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
key_type key() const;
                    <comment>
        Accessor for product key.
                    </comment>
                </method1>

                <method1 name="index"
                         return="key_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
key_type index() const;
                    <comment>
       This one just for backward compatibility.  Will be removed soon.
                    </comment>
                </method1>

                <method2 name="ref"
                         return="RefBase&lt;key_type&gt; const&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
RefBase&lt;key_type&gt; const&amp; ref() const;
                    <comment>
        Accessor for all data
                    </comment>
                </method2>

                <method1 name="hasProductCache"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasProductCache() const;
                </method1>

                <method1 name="hasCache"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasCache() const;
                </method1>

                <method1 name="isAvailable"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isAvailable() const;
                    <comment>
        in the Event. No type checking is done.
                    </comment>
                </method1>

                <method1 name="isTransient"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isTransient() const;
                    <comment>
        Checks if this ref is transient (i.e. not persistable).
                    </comment>
                </method1>

            </section>

            <typemap name="argument_type"
                     value="typename boost::binary_traits&lt;F&gt;::second_argument_type"
                     type="typedef"/>
            <typemap name="element_type"
                     value="T const"
                     type="typedef"/>
            <typemap name="finder_type"
                     value="F"
                     type="typedef"/>
            <typemap name="key_type"
                     value="typename boost::remove_cv&lt;typename boost::remove_reference&lt;typename boost::binary_traits&lt;F&gt;::second_argument_type&gt;::type&gt;::type"
                     type="typedef"/>
            <typemap name="product_type"
                     value="C"
                     type="typedef"/>
            <typemap name="value_type"
                     value="T"
                     type="typedef"/>

        </class>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/RefProd.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefCoreGet.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefItemGet.h&quot;"/>

    <namespace name="edm">
    </namespace>
    <include name="&quot;DataFormats/Common/interface/HolderToVectorTrait.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Holder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/VectorHolder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVector.h&quot;"/>

    <namespace name="edm">

        <namespace name="reftobase">

            <class name="RefHolderToVector"
                   fullname="edm::reftobase::RefHolderToVector&lt;T, REF&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T, typename REF&gt;">

                <section>
                    <method2 name="makeVectorHolder"
                             return="static std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt; makeVectorHolder();
                    </method2>

                    <method2 name="makeVectorBaseHolder"
                             return="static std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorBaseHolder();
                    </method2>

                </section>

            </class>

            <class name="HolderToVectorTrait&lt;T1, Ref&lt;C, T, F&gt; &gt;"
                   fullname="edm::reftobase::HolderToVectorTrait&lt;T1, Ref&lt;C, T, F&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T1, typename C, typename T, typename F&gt;">

                <section>
                    <typedef name="type"
                             value="RefHolderToVector&lt;T1, Ref&lt;C, T, F&gt; &gt;">
typedef RefHolderToVector&lt;T1, Ref&lt;C, T, F&gt; &gt; type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="RefHolderToVector&lt;T1, Ref&lt;C, T, F&gt; &gt;"
                         type="typedef"/>

            </class>

            <class name="RefRefHolderToRefVector"
                   fullname="edm::reftobase::RefRefHolderToRefVector&lt;REF&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename REF&gt;">

                <section>
                    <method2 name="makeVectorHolder"
                             return="static std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorHolder();
                    </method2>

                </section>

            </class>

            <class name="RefHolderToRefVectorTrait&lt;Ref&lt;C, T, F&gt; &gt;"
                   fullname="edm::reftobase::RefHolderToRefVectorTrait&lt;Ref&lt;C, T, F&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename C, typename T, typename F&gt;">

                <section>
                    <typedef name="type"
                             value="RefRefHolderToRefVector&lt;Ref&lt;C, T, F&gt; &gt;">
typedef RefRefHolderToRefVector&lt;Ref&lt;C, T, F&gt; &gt; type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="RefRefHolderToRefVector&lt;Ref&lt;C, T, F&gt; &gt;"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="EDProductGetter const*"/>
    <type name="Handle&lt;C&gt; const&amp;"/>
    <type name="OrphanHandle&lt;C&gt; const&amp;"/>
    <type name="ProductID"/>
    <type name="ProductID const&amp;"/>
    <type name="RefBase&lt;key_type&gt; const&amp;"/>
    <type name="RefProd&lt;C&gt; const&amp;"/>
    <type name="RefVector&lt;C, T, F&gt; const&amp;"/>
    <type name="TestHandle&lt;C&gt; const&amp;"/>
    <type name="bool"/>
    <type name="edm::Ref&lt;C, T, F&gt;"/>
    <type name="edm::reftobase::HolderToVectorTrait&lt;T1, Ref&lt;C, T, F&gt; &gt;"/>
    <type name="edm::reftobase::RefHolderToRefVectorTrait&lt;Ref&lt;C, T, F&gt; &gt;"/>
    <type name="edm::reftobase::RefHolderToVector&lt;T, REF&gt;"/>
    <type name="edm::reftobase::RefRefHolderToRefVector&lt;REF&gt;"/>
    <type name="key_type"/>
    <type name="std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"/>
    <type name="std::auto_ptr&lt;RefVectorHolderBase&gt;"/>
    <type name="void"/>
</header>
