<?xml version="1.0"?>
<!--
==============================================================================
  XML File: RefVector.xml
  Created:  Thu Jan 14 22:46:24 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/RefVector.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/RefVector.h">

    <include name="&lt;vector&gt;"/>
    <include name="&lt;stdexcept&gt;"/>
    <include name="&quot;DataFormats/Common/interface/EDProductfwd.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/FillView.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorBase.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefHolderBase.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorIterator.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefItem.h&quot;"/>
    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefTraits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorTraits.h&quot;"/>

    <namespace name="edm">

        <class name="RefVector"
               fullname="edm::RefVector&lt;C, T, F&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename C, typename T=typename refhelper::ValueTrait&lt;C&gt;::value, typename F=typename refhelper::FindTrait&lt;C, T&gt;::value&gt;">

            <section name="public">
                <typedef name="collection_type"
                         value="C">
typedef C collection_type;
                </typedef>

                <typedef name="member_type"
                         value="T">
typedef T member_type;
                </typedef>

                <typedef name="finder_type"
                         value="F">
typedef F finder_type;
                </typedef>

                <typedef name="iterator"
                         value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::iterator_type">
typedef typename refhelper::RefVectorTrait&lt;C, T, F&gt;::iterator_type iterator;
                </typedef>

                <typedef name="const_iterator"
                         value="iterator">
typedef iterator const_iterator;
                </typedef>

                <typedef name="value_type"
                         value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type">
typedef typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type value_type;
                </typedef>

                <typedef name="const_reference"
                         value="value_type const">
typedef value_type const const_reference;
                </typedef>

                <typedef name="reference"
                         value="const_reference">
typedef const_reference reference;
                </typedef>

                <typedef name="key_type"
                         value="typename value_type::key_type">
typedef typename value_type::key_type key_type;
                    <comment>
       key_type is the type of the key into the collection
                    </comment>
                </typedef>

                <typedef name="RefItemType"
                         value="RefItem&lt;key_type&gt;">
typedef RefItem&lt;key_type&gt; RefItemType;
                </typedef>

                <typedef name="RefItemVec"
                         value="std::vector&lt;RefItemType&gt;">
typedef std::vector&lt;RefItemType&gt; RefItemVec;
                </typedef>

                <typedef name="size_type"
                         value="typename RefItemVec::size_type">
typedef typename RefItemVec::size_type size_type;
                    <comment>
       size_type is the type of the index into the RefVector
                    </comment>
                </typedef>

                <typedef name="contents_type"
                         value="RefVectorBase&lt;key_type&gt;">
typedef RefVectorBase&lt;key_type&gt; contents_type;
                </typedef>

                <constructor name="RefVector"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
RefVector();
                    <comment>
        store. Not for direct use.
                    </comment>
                </constructor>

                <constructor name="RefVector"
                             return=""
                             args="['ProductID const&amp;']"
                             vars="['id']"
                             qual="">
RefVector(ProductID const&amp; id);
                </constructor>

                <method1 name="push_back"
                         return="void"
                         args="['value_type const&amp;']"
                         vars="['ref']"
                         qual="">
void push_back(value_type const&amp; ref);
                    <comment>
        Add a Ref&lt;C, T&gt; to the RefVector
                    </comment>
                </method1>

                <operator name="operator[]"
                          return="value_type const"
                          args="['size_type']"
                          vars="['idx']"
                          qual="const">
value_type const operator[](size_type idx) const;
                    <comment>
        Retrieve an element of the RefVector
                    </comment>
                </operator>

                <method1 name="at"
                         return="value_type const"
                         args="['size_type']"
                         vars="['idx']"
                         qual="const">
value_type const at(size_type idx) const;
                    <comment>
        Retrieve an element of the RefVector
                    </comment>
                </method1>

                <method1 name="refVector"
                         return="contents_type const&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
contents_type const&amp; refVector() const;
                    <comment>
        Accessor for all data
                    </comment>
                </method1>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                    <comment>
        Is the RefVector empty
                    </comment>
                </method1>

                <method1 name="size"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type size() const;
                    <comment>
        Size of the RefVector
                    </comment>
                </method1>

                <method1 name="capacity"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type capacity() const;
                    <comment>
        Capacity of the RefVector
                    </comment>
                </method1>

                <method1 name="reserve"
                         return="void"
                         args="['size_type']"
                         vars="['n']"
                         qual="">
void reserve(size_type n);
                    <comment>
        Reserve space for RefVector
                    </comment>
                </method1>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                    <comment>
        Initialize an iterator over the RefVector
                    </comment>
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                    <comment>
        Termination of iteration
                    </comment>
                </method1>

                <method1 name="id"
                         return="ProductID"
                         args="['void']"
                         vars="['']"
                         qual="const">
ProductID id() const;
                    <comment>
        Accessor for product ID.
                    </comment>
                </method1>

                <method1 name="productGetter"
                         return="EDProductGetter const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
EDProductGetter const* productGetter() const;
                    <comment>
        Accessor for product getter
                    </comment>
                </method1>

                <method1 name="isNull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNull() const;
                    <comment>
        Checks for null
                    </comment>
                </method1>

                <method1 name="isNonnull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNonnull() const;
                    <comment>
        Checks for non-null
                    </comment>
                </method1>

                <operator name="operator!"
                          return="bool"
                          args="['void']"
                          vars="['']"
                          qual="const">
bool operator!() const;
                    <comment>
        Checks for null
                    </comment>
                </operator>

                <method1 name="product"
                         return="C const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
C const* product() const;
                    <comment>
       Accessor must get the product if necessary
                    </comment>
                </method1>

                <method1 name="isAvailable"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isAvailable() const;
                    <comment>
        in the Event. No type checking is done.
                    </comment>
                </method1>

                <method1 name="isTransient"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isTransient() const;
                    <comment>
        Checks if product collection is tansient (i.e. non persistable)
                    </comment>
                </method1>

                <method1 name="erase"
                         return="iterator"
                         args="['iterator const&amp;']"
                         vars="['pos']"
                         qual="">
iterator erase(iterator const&amp; pos);
                    <comment>
        Erase an element from the vector.
                    </comment>
                </method1>

                <method1 name="clear"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void clear();
                    <comment>
        Clear the vector.
                    </comment>
                </method1>

                <method2 name="swap"
                         return="void"
                         args="['RefVector&lt;C, T, F&gt;&amp;']"
                         vars="['other']"
                         qual="">
void swap(RefVector&lt;C, T, F&gt;&amp; other);
                    <comment>
        Swap two vectors.
                    </comment>
                </method2>

                <operator name="operator="
                          return="RefVector&amp;"
                          args="['RefVector const&amp;']"
                          vars="['rhs']"
                          qual="">
RefVector&amp; operator=(RefVector const&amp; rhs);
                    <comment>
        Copy assignment.
                    </comment>
                </operator>

                <method1 name="hasProductCache"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasProductCache() const;
                    <comment>
        Checks if product is in memory.
                    </comment>
                </method1>

                <method2 name="fillView"
                         return="void"
                         args="['ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector&amp;']"
                         vars="['id','pointers','helpers']"
                         qual="const">
void fillView(ProductID const&amp; id, std::vector&lt;void const*&gt;&amp; pointers, helper_vector&amp; helpers) const;
                </method2>

            </section>

            <typemap name="RefItemType"
                     value="RefItem&lt;typename typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type::key_type&gt;"
                     type="typedef"/>
            <typemap name="RefItemVec"
                     value="std::vector&lt;RefItem&lt;typename typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type::key_type&gt; &gt;"
                     type="typedef"/>
            <typemap name="collection_type"
                     value="C"
                     type="typedef"/>
            <typemap name="const_iterator"
                     value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::iterator_type"
                     type="typedef"/>
            <typemap name="const_reference"
                     value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type const"
                     type="typedef"/>
            <typemap name="contents_type"
                     value="RefVectorBase&lt;typename typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type::key_type&gt;"
                     type="typedef"/>
            <typemap name="finder_type"
                     value="F"
                     type="typedef"/>
            <typemap name="iterator"
                     value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::iterator_type"
                     type="typedef"/>
            <typemap name="key_type"
                     value="typename typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type::key_type"
                     type="typedef"/>
            <typemap name="member_type"
                     value="T"
                     type="typedef"/>
            <typemap name="reference"
                     value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type const"
                     type="typedef"/>
            <typemap name="size_type"
                     value="typename std::vector&lt;RefItem&lt;typename typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type::key_type&gt; &gt;::size_type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="typename refhelper::RefVectorTrait&lt;C, T, F&gt;::ref_type"
                     type="typedef"/>

        </class>

        <class name="has_fillView&lt;edm::RefVector&lt;C,T,F&gt; &gt;"
               fullname="edm::has_fillView&lt;edm::RefVector&lt;C,T,F&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template struct"
               template="template&lt;typename C, typename T, typename F&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;edm::RefVector&lt;C, T, F&gt; &gt;::true"
                     type="member"/>

        </class>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/RefCoreGet.h&quot;"/>

    <namespace name="edm">
    </namespace>
    <include name="&quot;DataFormats/Common/interface/GetProduct.h&quot;"/>

    <namespace name="edm">

        <namespace name="detail">

            <class name="GetProduct&lt;RefVector&lt;C, T, F&gt; &gt;"
                   fullname="edm::detail::GetProduct&lt;RefVector&lt;C, T, F&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename C, typename T, typename F&gt;">

                <section>
                    <typedef name="element_type"
                             value="T">
typedef T element_type;
                    </typedef>

                    <typedef name="iter"
                             value="typename RefVector&lt;C, T, F&gt;::const_iterator">
typedef typename RefVector&lt;C, T, F&gt;::const_iterator iter;
                    </typedef>

                    <method1 name="address"
                             return="static const element_type*"
                             args="['const iter&amp;']"
                             vars="['i']"
                             qual="">
static const element_type* address(const iter&amp; i);
                    </method1>

                    <method2 name="product"
                             return="static const C*"
                             args="['const RefVector&lt;C, T, F&gt;&amp;']"
                             vars="['coll']"
                             qual="">
static const C* product(const RefVector&lt;C, T, F&gt;&amp; coll);
                    </method2>

                </section>

                <typemap name="element_type"
                         value="T"
                         type="typedef"/>
                <typemap name="iter"
                         value="typename RefVector&lt;C, T, F&gt;::const_iterator"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="EDProductGetter const*"/>
    <type name="ProductID"/>
    <type name="ProductID const&amp;"/>
    <type name="RefVector const&amp;"/>
    <type name="RefVector&amp;"/>
    <type name="RefVector&lt;C, T, F&gt;&amp;"/>
    <type name="bool"/>
    <type name="bool const value"/>
    <type name="const RefVector&lt;C, T, F&gt;&amp;"/>
    <type name="const element_type*"/>
    <type name="const iter&amp;"/>
    <type name="const_iterator"/>
    <type name="contents_type const&amp;"/>
    <type name="edm::RefVector&lt;C, T, F&gt;"/>
    <type name="edm::detail::GetProduct&lt;RefVector&lt;C, T, F&gt; &gt;"/>
    <type name="edm::has_fillView&lt;edm::RefVector&lt;C, T, F&gt; &gt;"/>
    <type name="helper_vector&amp;"/>
    <type name="iterator"/>
    <type name="iterator const&amp;"/>
    <type name="size_type"/>
    <type name="std::vector&lt;void const*&gt;&amp;"/>
    <type name="value_type const"/>
    <type name="value_type const&amp;"/>
    <type name="void"/>
</header>
