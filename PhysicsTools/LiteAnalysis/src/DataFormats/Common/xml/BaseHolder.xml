<?xml version="1.0"?>
<!--
==============================================================================
  XML File: BaseHolder.xml
  Created:  Thu Jan 14 22:45:50 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/BaseHolder.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/BaseHolder.h">

    <include name="&quot;DataFormats/Common/interface/EDProductGetter.h&quot;"/>
    <include name="&lt;string&gt;"/>

    <namespace name="edm">
        <forward name="ProductID"/>
        <forward name="RefHolderBase"/>

        <namespace name="reftobase">
            <forward name="template&lt;typename T&gt; BaseVectorHolder"/>
            <forward name="RefVectorHolderBase"/>

            <class name="BaseHolder"
                   fullname="edm::reftobase::BaseHolder&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="abstract template protectedcopyctor"
                   template="template&lt;typename T&gt;">
                <comment>
       Class template BaseHolder&lt;T&gt;

       BaseHolder&lt;T&gt; is an abstract base class that manages a single
       edm::Ref to an element of type T in a collection in the Event;
       the purpose of this abstraction is to hide the type of the
       collection from code that can not know about that type.
                </comment>

                <section name="public">
                    <constructor name="BaseHolder"
                                 return=""
                                 args="['void']"
                                 vars="['']"
                                 qual="">
BaseHolder();
                    </constructor>

                    <destructor name="~BaseHolder"
                                return="virtual"
                                args="['void']"
                                vars="['']"
                                qual="">
virtual ~BaseHolder();
                    </destructor>

                    <method2 name="clone"
                             return="virtual BaseHolder&lt;T&gt;*"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual BaseHolder&lt;T&gt;* clone() const=0;
                    </method2>

                    <method1 name="swap"
                             return="void"
                             args="['BaseHolder&amp;']"
                             vars="['']"
                             qual="">
void swap(BaseHolder&amp;);
                    </method1>

                    <method1 name="getPtr"
                             return="virtual T const*"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual T const* getPtr() const=0;
                        <comment>
         Return the address of the element to which the hidden Ref
         refers.
                        </comment>
                    </method1>

                    <method1 name="id"
                             return="virtual ProductID"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual ProductID id() const=0;
                        <comment>
         Return the ProductID of the collection to which the hidden
         Ref refers.
                        </comment>
                    </method1>

                    <method1 name="key"
                             return="virtual size_t"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual size_t key() const=0;
                    </method1>

                    <method2 name="isEqualTo"
                             return="virtual bool"
                             args="['BaseHolder&lt;T&gt; const&amp;']"
                             vars="['rhs']"
                             qual="const = 0">
virtual bool isEqualTo(BaseHolder&lt;T&gt; const&amp; rhs) const=0;
                        <comment>
         Check to see if the Ref hidden in 'rhs' is equal to the Ref
         hidden in 'this'. They can not be equal if they are of
         different types. Note that the equality test also returns
         false if dynamic type of 'rhs' is different from the dynamic
         type of 'this', *even when the hiddens Refs are actually
         equivalent*.
                        </comment>
                    </method2>

                    <method1 name="fillRefIfMyTypeMatches"
                             return="virtual bool"
                             args="['RefHolderBase&amp;','std::string&amp;']"
                             vars="['fillme','msg']"
                             qual="const = 0">
virtual bool fillRefIfMyTypeMatches(RefHolderBase&amp; fillme, std::string&amp; msg) const=0;
                        <comment>
         If the type of Ref I contain matches the type contained in
         'fillme', set the Ref in 'fillme' equal to mine and return
         true. If not, write the name of the type I really contain to
         msg, and return false.
                        </comment>
                    </method1>

                    <method2 name="holder"
                             return="virtual std::auto_ptr&lt;RefHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual std::auto_ptr&lt;RefHolderBase&gt; holder() const=0;
                    </method2>

                    <method2 name="makeVectorHolder"
                             return="virtual std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt; makeVectorHolder() const=0;
                    </method2>

                    <method2 name="makeVectorBaseHolder"
                             return="virtual std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorBaseHolder() const=0;
                    </method2>

                    <method1 name="productGetter"
                             return="virtual EDProductGetter const*"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual EDProductGetter const* productGetter() const=0;
                    </method1>

                    <method1 name="hasProductCache"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual bool hasProductCache() const=0;
                    </method1>

                    <method1 name="product"
                             return="virtual void const*"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual void const* product() const=0;
                    </method1>

                    <method1 name="isAvailable"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const = 0">
virtual bool isAvailable() const=0;
                        <comment>
          in the Event. No type checking is done.
                        </comment>
                    </method1>

                </section>

            </class>
        </namespace>
    </namespace>

    <type name="BaseHolder&amp;"/>
    <type name="BaseHolder&lt;T&gt; const&amp;"/>
    <type name="BaseHolder&lt;T&gt;*"/>
    <type name="EDProductGetter const*"/>
    <type name="ProductID"/>
    <type name="RefHolderBase&amp;"/>
    <type name="bool"/>
    <type name="edm::reftobase::BaseHolder&lt;T&gt;"/>
    <type name="size_t"/>
    <type name="std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"/>
    <type name="std::auto_ptr&lt;RefHolderBase&gt;"/>
    <type name="std::auto_ptr&lt;RefVectorHolderBase&gt;"/>
    <type name="std::string&amp;"/>
    <type name="void"/>
    <type name="void const*"/>
</header>
