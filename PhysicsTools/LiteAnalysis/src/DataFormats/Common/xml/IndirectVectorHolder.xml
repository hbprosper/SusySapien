<?xml version="1.0"?>
<!--
==============================================================================
  XML File: IndirectVectorHolder.xml
  Created:  Fri Jan 15 20:45:38 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/IndirectVectorHolder.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/IndirectVectorHolder.h">

    <include name="&quot;DataFormats/Common/interface/BaseVectorHolder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorHolderBase.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/IndirectHolder.h&quot;"/>

    <namespace name="edm">

        <namespace name="reftobase">

            <class name="IndirectVectorHolder"
                   fullname="edm::reftobase::IndirectVectorHolder&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template"
                   template="template&lt;typename T&gt;">
                <baseclass name="public BaseVectorHolder&lt;T&gt;"/>

                <section name="public">
                    <typedef name="base_type"
                             value="BaseVectorHolder&lt;T&gt;">
typedef BaseVectorHolder&lt;T&gt; base_type;
                    </typedef>

                    <typedef name="size_type"
                             value="typename base_type::size_type">
typedef typename base_type::size_type size_type;
                    </typedef>

                    <typedef name="element_type"
                             value="typename base_type::element_type">
typedef typename base_type::element_type element_type;
                    </typedef>

                    <typedef name="base_ref_type"
                             value="typename base_type::base_ref_type">
typedef typename base_type::base_ref_type base_ref_type;
                    </typedef>

                    <typedef name="const_iterator"
                             value="typename base_type::const_iterator">
typedef typename base_type::const_iterator const_iterator;
                    </typedef>

                    <constructor name="IndirectVectorHolder"
                                 return=""
                                 args="['void']"
                                 vars="['']"
                                 qual="">
IndirectVectorHolder();
                    </constructor>

                    <copyconstructor name="IndirectVectorHolder"
                                     return=""
                                     args="['const IndirectVectorHolder&amp;']"
                                     vars="['other']"
                                     qual="">
IndirectVectorHolder(const IndirectVectorHolder&amp; other);
                    </copyconstructor>

                    <constructor name="IndirectVectorHolder"
                                 return=""
                                 args="['boost::shared_ptr&lt;RefVectorHolderBase&gt;']"
                                 vars="['p']"
                                 qual="">
IndirectVectorHolder(boost::shared_ptr&lt;RefVectorHolderBase&gt; p);
                    </constructor>

                    <constructor name="IndirectVectorHolder"
                                 return=""
                                 args="['RefVectorHolderBase*']"
                                 vars="['p']"
                                 qual="">
IndirectVectorHolder(RefVectorHolderBase* p);
                    </constructor>

                    <destructor name="~IndirectVectorHolder"
                                return="virtual"
                                args="['void']"
                                vars="['']"
                                qual="">
virtual ~IndirectVectorHolder();
                    </destructor>

                    <operator name="operator="
                              return="IndirectVectorHolder&amp;"
                              args="['IndirectVectorHolder const&amp;']"
                              vars="['rhs']"
                              qual="">
IndirectVectorHolder&amp; operator=(IndirectVectorHolder const&amp; rhs);
                    </operator>

                    <method1 name="swap"
                             return="void"
                             args="['IndirectVectorHolder&amp;']"
                             vars="['other']"
                             qual="">
void swap(IndirectVectorHolder&amp; other);
                    </method1>

                    <method2 name="clone"
                             return="virtual BaseVectorHolder&lt;T&gt;*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual BaseVectorHolder&lt;T&gt;* clone() const;
                    </method2>

                    <method2 name="cloneEmpty"
                             return="virtual BaseVectorHolder&lt;T&gt;*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual BaseVectorHolder&lt;T&gt;* cloneEmpty() const;
                    </method2>

                    <method1 name="id"
                             return="virtual ProductID"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual ProductID id() const;
                    </method1>

                    <method1 name="productGetter"
                             return="virtual EDProductGetter const*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual EDProductGetter const* productGetter() const;
                    </method1>

                    <method1 name="empty"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual bool empty() const;
                    </method1>

                    <method1 name="size"
                             return="virtual size_type"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual size_type size() const;
                    </method1>

                    <method1 name="clear"
                             return="virtual void"
                             args="['void']"
                             vars="['']"
                             qual="">
virtual void clear();
                    </method1>

                    <method1 name="at"
                             return="virtual base_ref_type const"
                             args="['size_type']"
                             vars="['idx']"
                             qual="const">
virtual base_ref_type const at(size_type idx) const;
                    </method1>

                    <method2 name="vectorHolder"
                             return="virtual std::auto_ptr&lt;reftobase::RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual std::auto_ptr&lt;reftobase::RefVectorHolderBase&gt; vectorHolder() const;
                    </method2>

                    <method2 name="push_back"
                             return="virtual void"
                             args="['const BaseHolder&lt;T&gt;*']"
                             vars="['r']"
                             qual="">
virtual void push_back(const BaseHolder&lt;T&gt;* r);
                    </method2>

                    <method1 name="product"
                             return="virtual const void*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual const void* product() const;
                    </method1>

                    <method1 name="isAvailable"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual bool isAvailable() const;
                        <comment>
          in the Event. No type checking is done.
                        </comment>
                    </method1>

                </section>
                <section name="public">

                    <class name="const_iterator_imp_specific"
                           fullname="edm::reftobase::IndirectVectorHolder&lt;T&gt;::const_iterator_imp_specific"
                           module="DataFormats.Common"
                           project=""
                           type="regular struct">
                        <baseclass name="public const_iterator_imp"/>

                        <section>
                            <typedef name="difference_type"
                                     value="ptrdiff_t">
typedef ptrdiff_t difference_type;
                            </typedef>

                            <constructor name="const_iterator_imp_specific"
                                         return=""
                                         args="['void']"
                                         vars="['']"
                                         qual="">
const_iterator_imp_specific();
                            </constructor>

                            <constructor name="const_iterator_imp_specific"
                                         return="explicit"
                                         args="['const typename RefVectorHolderBase::const_iterator&amp;']"
                                         vars="['it']"
                                         qual="">
explicit const_iterator_imp_specific(const typename RefVectorHolderBase::const_iterator&amp; it);
                            </constructor>

                            <destructor name="~const_iterator_imp_specific"
                                        return=""
                                        args="['void']"
                                        vars="['']"
                                        qual="">
~const_iterator_imp_specific();
                            </destructor>

                            <method1 name="clone"
                                     return="const_iterator_imp_specific*"
                                     args="['void']"
                                     vars="['']"
                                     qual="const">
const_iterator_imp_specific* clone() const;
                            </method1>

                            <method1 name="increase"
                                     return="void"
                                     args="['void']"
                                     vars="['']"
                                     qual="">
void increase();
                            </method1>

                            <method1 name="decrease"
                                     return="void"
                                     args="['void']"
                                     vars="['']"
                                     qual="">
void decrease();
                            </method1>

                            <method1 name="increase"
                                     return="void"
                                     args="['difference_type']"
                                     vars="['d']"
                                     qual="">
void increase(difference_type d);
                            </method1>

                            <method1 name="decrease"
                                     return="void"
                                     args="['difference_type']"
                                     vars="['d']"
                                     qual="">
void decrease(difference_type d);
                            </method1>

                            <method1 name="equal_to"
                                     return="bool"
                                     args="['const const_iterator_imp*']"
                                     vars="['o']"
                                     qual="const">
bool equal_to(const const_iterator_imp* o) const;
                            </method1>

                            <method1 name="less_than"
                                     return="bool"
                                     args="['const const_iterator_imp*']"
                                     vars="['o']"
                                     qual="const">
bool less_than(const const_iterator_imp* o) const;
                            </method1>

                            <method1 name="assign"
                                     return="void"
                                     args="['const const_iterator_imp*']"
                                     vars="['o']"
                                     qual="">
void assign(const const_iterator_imp* o);
                            </method1>

                            <method1 name="deref"
                                     return="base_ref_type"
                                     args="['void']"
                                     vars="['']"
                                     qual="const">
base_ref_type deref() const;
                            </method1>

                            <method1 name="difference"
                                     return="difference_type"
                                     args="['const const_iterator_imp*']"
                                     vars="['o']"
                                     qual="const">
difference_type difference(const const_iterator_imp* o) const;
                            </method1>

                        </section>

                        <typemap name="const_iterator_imp_specific"
                                 value="edm::reftobase::IndirectVectorHolder&lt;T&gt;::const_iterator_imp_specific"
                                 type="class"/>
                        <typemap name="difference_type"
                                 value="ptrdiff_t"
                                 type="typedef"/>

                    </class>
                    <method1 name="begin"
                             return="const_iterator"
                             args="['void']"
                             vars="['']"
                             qual="const">
const_iterator begin() const;
                    </method1>

                    <method1 name="end"
                             return="const_iterator"
                             args="['void']"
                             vars="['']"
                             qual="const">
const_iterator end() const;
                    </method1>

                </section>

                <typemap name="base_ref_type"
                         value="typename BaseVectorHolder&lt;T&gt;::base_ref_type"
                         type="typedef"/>
                <typemap name="base_type"
                         value="BaseVectorHolder&lt;T&gt;"
                         type="typedef"/>
                <typemap name="const_iterator"
                         value="typename BaseVectorHolder&lt;T&gt;::const_iterator"
                         type="typedef"/>
                <typemap name="element_type"
                         value="typename BaseVectorHolder&lt;T&gt;::element_type"
                         type="typedef"/>
                <typemap name="size_type"
                         value="typename BaseVectorHolder&lt;T&gt;::size_type"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="BaseVectorHolder&lt;T&gt;"/>
    <type name="BaseVectorHolder&lt;T&gt;*"/>
    <type name="EDProductGetter const*"/>
    <type name="IndirectVectorHolder const&amp;"/>
    <type name="IndirectVectorHolder&amp;"/>
    <type name="ProductID"/>
    <type name="RefVectorHolderBase*"/>
    <type name="base_ref_type"/>
    <type name="base_ref_type const"/>
    <type name="bool"/>
    <type name="boost::shared_ptr&lt;RefVectorHolderBase&gt;"/>
    <type name="const BaseHolder&lt;T&gt;*"/>
    <type name="const IndirectVectorHolder&amp;"/>
    <type name="const const_iterator_imp*"/>
    <type name="const typename RefVectorHolderBase::const_iterator&amp;"/>
    <type name="const void*"/>
    <type name="const_iterator"/>
    <type name="const_iterator_imp"/>
    <type name="const_iterator_imp_specific*"/>
    <type name="difference_type"/>
    <type name="edm::reftobase::IndirectVectorHolder&lt;T&gt;"/>
    <type name="edm::reftobase::IndirectVectorHolder&lt;T&gt;::const_iterator_imp_specific"/>
    <type name="size_type"/>
    <type name="std::auto_ptr&lt;reftobase::RefVectorHolderBase&gt;"/>
    <type name="void"/>
</header>
