<?xml version="1.0"?>
<!--
==============================================================================
  XML File: IndirectHolder.xml
  Created:  Fri Jan 15 20:45:38 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/IndirectHolder.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/IndirectHolder.h">

    <include name="&quot;DataFormats/Common/interface/BaseHolder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefHolderBase.h&quot;"/>
    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&quot;boost/shared_ptr.hpp&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;typename T&gt; RefToBase"/>

        <namespace name="reftobase">
            <forward name="template&lt;typename T&gt; IndirectVectorHolder"/>
            <forward name="RefVectorHolderBase"/>
            <forward name="RefHolderBase"/>

            <class name="IndirectHolder"
                   fullname="edm::reftobase::IndirectHolder&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template"
                   template="template&lt;typename T&gt;">
                <baseclass name="public BaseHolder&lt;T&gt;"/>
                <comment>
       Class template IndirectHolder&lt;T&gt;
                </comment>

                <section name="public">
                    <constructor name="IndirectHolder"
                                 return=""
                                 args="['void']"
                                 vars="['']"
                                 qual="">
IndirectHolder();
                        <comment>
         It may be better to use auto_ptr&lt;RefHolderBase&gt; in
         this constructor, so that the cloning can be avoided. I'm not
         sure if use of auto_ptr here causes any troubles elsewhere.
                        </comment>
                    </constructor>

                    <constructor name="IndirectHolder"
                                 return=""
                                 args="['boost::shared_ptr&lt;RefHolderBase&gt;']"
                                 vars="['p']"
                                 qual="">
IndirectHolder(boost::shared_ptr&lt;RefHolderBase&gt; p);
                    </constructor>

                    <copyconstructor name="IndirectHolder"
                                     return=""
                                     args="['IndirectHolder const&amp;']"
                                     vars="['other']"
                                     qual="">
IndirectHolder(IndirectHolder const&amp; other);
                    </copyconstructor>

                    <operator name="operator="
                              return="IndirectHolder&amp;"
                              args="['IndirectHolder const&amp;']"
                              vars="['rhs']"
                              qual="">
IndirectHolder&amp; operator=(IndirectHolder const&amp; rhs);
                    </operator>

                    <method1 name="swap"
                             return="void"
                             args="['IndirectHolder&amp;']"
                             vars="['other']"
                             qual="">
void swap(IndirectHolder&amp; other);
                    </method1>

                    <destructor name="~IndirectHolder"
                                return="virtual"
                                args="['void']"
                                vars="['']"
                                qual="">
virtual ~IndirectHolder();
                    </destructor>

                    <method2 name="clone"
                             return="virtual BaseHolder&lt;T&gt;*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual BaseHolder&lt;T&gt;* clone() const;
                    </method2>

                    <method1 name="getPtr"
                             return="virtual T const*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual T const* getPtr() const;
                    </method1>

                    <method1 name="id"
                             return="virtual ProductID"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual ProductID id() const;
                    </method1>

                    <method1 name="key"
                             return="virtual size_t"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual size_t key() const;
                    </method1>

                    <method2 name="isEqualTo"
                             return="virtual bool"
                             args="['BaseHolder&lt;T&gt; const&amp;']"
                             vars="['rhs']"
                             qual="const">
virtual bool isEqualTo(BaseHolder&lt;T&gt; const&amp; rhs) const;
                    </method2>

                    <method1 name="fillRefIfMyTypeMatches"
                             return="virtual bool"
                             args="['RefHolderBase&amp;','std::string&amp;']"
                             vars="['fillme','msg']"
                             qual="const">
virtual bool fillRefIfMyTypeMatches(RefHolderBase&amp; fillme, std::string&amp; msg) const;
                    </method1>

                    <method2 name="holder"
                             return="virtual std::auto_ptr&lt;RefHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual std::auto_ptr&lt;RefHolderBase&gt; holder() const;
                    </method2>

                    <method2 name="makeVectorHolder"
                             return="virtual std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt; makeVectorHolder() const;
                    </method2>

                    <method2 name="makeVectorBaseHolder"
                             return="virtual std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorBaseHolder() const;
                    </method2>

                    <method1 name="productGetter"
                             return="virtual EDProductGetter const*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual EDProductGetter const* productGetter() const;
                    </method1>

                    <method1 name="hasProductCache"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual bool hasProductCache() const;
                    </method1>

                    <method1 name="product"
                             return="virtual void const*"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual void const* product() const;
                    </method1>

                    <method1 name="isAvailable"
                             return="virtual bool"
                             args="['void']"
                             vars="['']"
                             qual="const">
virtual bool isAvailable() const;
                        <comment>
          in the Event. No type checking is done.
                        </comment>
                    </method1>

                </section>

            </class>
        </namespace>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/IndirectVectorHolder.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefVectorHolderBase.h&quot;"/>

    <namespace name="edm">

        <namespace name="reftobase">
        </namespace>
    </namespace>

    <type name="BaseHolder&lt;T&gt;"/>
    <type name="BaseHolder&lt;T&gt; const&amp;"/>
    <type name="BaseHolder&lt;T&gt;*"/>
    <type name="EDProductGetter const*"/>
    <type name="IndirectHolder const&amp;"/>
    <type name="IndirectHolder&amp;"/>
    <type name="ProductID"/>
    <type name="RefHolderBase&amp;"/>
    <type name="bool"/>
    <type name="boost::shared_ptr&lt;RefHolderBase&gt;"/>
    <type name="edm::reftobase::IndirectHolder&lt;T&gt;"/>
    <type name="size_t"/>
    <type name="std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"/>
    <type name="std::auto_ptr&lt;RefHolderBase&gt;"/>
    <type name="std::auto_ptr&lt;RefVectorHolderBase&gt;"/>
    <type name="std::string&amp;"/>
    <type name="void"/>
    <type name="void const*"/>
</header>
