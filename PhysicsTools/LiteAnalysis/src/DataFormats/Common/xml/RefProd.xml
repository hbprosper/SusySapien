<?xml version="1.0"?>
<!--
==============================================================================
  XML File: RefProd.xml
  Created:  Thu Jan 14 22:46:21 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/RefProd.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/RefProd.h">

    <include name="&quot;DataFormats/Common/interface/EDProductfwd.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/EDProductGetter.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefCore.h&quot;"/>
    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Handle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OrphanHandle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/TestHandle.h&quot;"/>

    <namespace name="edm">

        <class name="RefProd"
               fullname="edm::RefProd&lt;C&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename C&gt;">

            <section name="public">
                <typedef name="product_type"
                         value="C">
typedef C product_type;
                </typedef>

                <typedef name="value_type"
                         value="C">
typedef C value_type;
                </typedef>

                <constructor name="RefProd"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
RefProd();
                    <comment>
        Default constructor needed for reading from persistent store. Not for direct use.
                    </comment>
                </constructor>

                <constructor name="RefProd"
                             return="explicit"
                             args="['Handle&lt;C&gt; const&amp;']"
                             vars="['handle']"
                             qual="">
explicit RefProd(Handle&lt;C&gt; const&amp; handle);
                    <comment>
        General purpose constructor from handle.
                    </comment>
                </constructor>

                <constructor name="RefProd"
                             return="explicit"
                             args="['OrphanHandle&lt;C&gt; const&amp;']"
                             vars="['handle']"
                             qual="">
explicit RefProd(OrphanHandle&lt;C&gt; const&amp; handle);
                    <comment>
        General purpose constructor from orphan handle.
                    </comment>
                </constructor>

                <constructor name="RefProd"
                             return=""
                             args="['C const*']"
                             vars="['product']"
                             qual="">
RefProd(C const* product);
                    <comment>
        An exception will be thrown if an attempt is made to persistify
        any object containing this RefProd.  Also, in the future work will
        be done to throw an exception if an attempt is made to put any object
        containing this RefProd into an event(or run or lumi).
                    </comment>
                </constructor>

                <constructor name="RefProd"
                             return="explicit"
                             args="['TestHandle&lt;C&gt; const&amp;']"
                             vars="['handle']"
                             qual="">
explicit RefProd(TestHandle&lt;C&gt; const&amp; handle);
                    <comment>
        An exception will be thrown if an attempt is made to persistify
        any object containing this RefProd.  Also, in the future work will
        be done to throw an exception if an attempt is made to put any object
        containing this RefProd into an event(or run or lumi).
                    </comment>
                </constructor>

                <method2 name="RefProd"
                         return="template&lt;typename T, typename F&gt; explicit"
                         args="['Ref&lt;C, T, F&gt; const&amp;']"
                         vars="['ref']"
                         qual="">
template&lt;typename T, typename F&gt;     explicit RefProd(Ref&lt;C, T, F&gt; const&amp; ref);
                    <comment>
        Constructor from Ref&lt;C,T,F&gt;
                    </comment>
                </method2>

                <method2 name="RefProd"
                         return="template&lt;typename T, typename F&gt; explicit"
                         args="['RefVector&lt;C, T, F&gt; const&amp;']"
                         vars="['ref']"
                         qual="">
template&lt;typename T, typename F&gt;     explicit RefProd(RefVector&lt;C, T, F&gt; const&amp; ref);
                    <comment>
        Constructor from RefVector&lt;C,T,F&gt;
                    </comment>
                </method2>

                <constructor name="RefProd"
                             return=""
                             args="['ProductID const&amp;','EDProductGetter const*']"
                             vars="['productID','prodGetter']"
                             qual="">
RefProd(ProductID const&amp; productID, EDProductGetter const* prodGetter);
                    <comment>
       Constructor for those users who do not have a product handle,
       but have a pointer to a product getter (such as the EventPrincipal).
       prodGetter will ususally be a pointer to the event principal.
                    </comment>
                </constructor>

                <destructor name="~RefProd"
                            return=""
                            args="['void']"
                            vars="['']"
                            qual="">
~RefProd();
                    <comment>
        Destructor
                    </comment>
                </destructor>

                <operator name="operator*"
                          return="product_type const&amp;"
                          args="['void']"
                          vars="['']"
                          qual="const">
product_type const&amp; operator*() const;
                    <comment>
        Dereference operator
                    </comment>
                </operator>

                <operator name="operator-&gt;"
                          return="product_type const*"
                          args="['void']"
                          vars="['']"
                          qual="const">
product_type const* operator-&gt;() const;
                    <comment>
        Member dereference operator
                    </comment>
                </operator>

                <method1 name="get"
                         return="product_type const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
product_type const* get() const;
                    <comment>
        Will attempt to retrieve product
                    </comment>
                </method1>

                <method1 name="product"
                         return="product_type const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
product_type const* product() const;
                    <comment>
        Will attempt to retrieve product
                    </comment>
                </method1>

                <method1 name="refCore"
                         return="RefCore const&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
RefCore const&amp; refCore() const;
                </method1>

                <method1 name="isNull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNull() const;
                    <comment>
        Checks for null
                    </comment>
                </method1>

                <method1 name="isNonnull"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isNonnull() const;
                    <comment>
        Checks for non-null
                    </comment>
                </method1>

                <operator name="operator!"
                          return="bool"
                          args="['void']"
                          vars="['']"
                          qual="const">
bool operator!() const;
                    <comment>
        Checks for null
                    </comment>
                </operator>

                <method1 name="id"
                         return="ProductID"
                         args="['void']"
                         vars="['']"
                         qual="const">
ProductID id() const;
                    <comment>
        Accessor for product ID.
                    </comment>
                </method1>

                <method1 name="productGetter"
                         return="EDProductGetter const*"
                         args="['void']"
                         vars="['']"
                         qual="const">
EDProductGetter const* productGetter() const;
                    <comment>
        Accessor for product getter.
                    </comment>
                </method1>

                <method1 name="hasCache"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasCache() const;
                    <comment>
        Checks if product is in memory.
                    </comment>
                </method1>

                <method1 name="hasProductCache"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool hasProductCache() const;
                    <comment>
        Checks if product is in memory.
                    </comment>
                </method1>

                <method1 name="isAvailable"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isAvailable() const;
                    <comment>
        in the Event. No type checking is done.
                    </comment>
                </method1>

                <method1 name="isTransient"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool isTransient() const;
                    <comment>
        Checks if this RefProd is transient (i.e. not persistable).
                    </comment>
                </method1>

                <method2 name="swap"
                         return="void"
                         args="['RefProd&lt;C&gt;&amp;']"
                         vars="['']"
                         qual="">
void swap(RefProd&lt;C&gt;&amp;);
                </method2>

            </section>

            <typemap name="product_type"
                     value="C"
                     type="typedef"/>
            <typemap name="value_type"
                     value="C"
                     type="typedef"/>

        </class>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/RefCoreGet.h&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;typename C, typename T, typename F&gt;
  RefVector"/>
    </namespace>
    <include name="&quot;DataFormats/Common/interface/HolderToVectorTrait.h&quot;"/>

    <namespace name="edm">

        <namespace name="reftobase">

            <class name="RefProdHolderToVector"
                   fullname="edm::reftobase::RefProdHolderToVector&lt;T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T&gt;">

                <section>
                    <method2 name="makeVectorHolder"
                             return="static std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt; makeVectorHolder();
                    </method2>

                    <method2 name="makeVectorBaseHolder"
                             return="static std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorBaseHolder();
                    </method2>

                </section>

            </class>

            <class name="HolderToVectorTrait&lt;T, RefProd&lt;C&gt; &gt;"
                   fullname="edm::reftobase::HolderToVectorTrait&lt;T, RefProd&lt;C&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename C, typename T&gt;">

                <section>
                    <typedef name="type"
                             value="RefProdHolderToVector&lt;T&gt;">
typedef RefProdHolderToVector&lt;T&gt; type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="RefProdHolderToVector&lt;T&gt;"
                         type="typedef"/>

            </class>

            <class name="RefProdRefHolderToRefVector"
                   fullname="edm::reftobase::RefProdRefHolderToRefVector"
                   module="DataFormats.Common"
                   project=""
                   type="regular struct">

                <section>
                    <method2 name="makeVectorHolder"
                             return="static std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorHolder();
                    </method2>

                    <method2 name="makeVectorBaseHolder"
                             return="static std::auto_ptr&lt;RefVectorHolderBase&gt;"
                             args="['void']"
                             vars="['']"
                             qual="">
static std::auto_ptr&lt;RefVectorHolderBase&gt; makeVectorBaseHolder();
                    </method2>

                </section>

            </class>

            <class name="RefHolderToRefVectorTrait&lt;RefProd&lt;C&gt; &gt;"
                   fullname="edm::reftobase::RefHolderToRefVectorTrait&lt;RefProd&lt;C&gt; &gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename C&gt;">

                <section>
                    <typedef name="type"
                             value="RefProdRefHolderToRefVector">
typedef RefProdRefHolderToRefVector type;
                    </typedef>

                </section>

                <typemap name="type"
                         value="RefProdRefHolderToRefVector"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="EDProductGetter const*"/>
    <type name="Handle&lt;C&gt; const&amp;"/>
    <type name="OrphanHandle&lt;C&gt; const&amp;"/>
    <type name="ProductID"/>
    <type name="ProductID const&amp;"/>
    <type name="Ref&lt;C, T, F&gt; const&amp;"/>
    <type name="RefCore const&amp;"/>
    <type name="RefProd&lt;C&gt;&amp;"/>
    <type name="RefVector&lt;C, T, F&gt; const&amp;"/>
    <type name="TestHandle&lt;C&gt; const&amp;"/>
    <type name="bool"/>
    <type name="edm::RefProd&lt;C&gt;"/>
    <type name="edm::reftobase::HolderToVectorTrait&lt;T, RefProd&lt;C&gt; &gt;"/>
    <type name="edm::reftobase::RefHolderToRefVectorTrait&lt;RefProd&lt;C&gt; &gt;"/>
    <type name="edm::reftobase::RefProdHolderToVector&lt;T&gt;"/>
    <type name="edm::reftobase::RefProdRefHolderToRefVector"/>
    <type name="product_type const&amp;"/>
    <type name="product_type const*"/>
    <type name="std::auto_ptr&lt;BaseVectorHolder&lt;T&gt; &gt;"/>
    <type name="std::auto_ptr&lt;RefVectorHolderBase&gt;"/>
    <type name="template&lt;typename T, typename F&gt; explicit"/>
    <type name="void"/>
</header>
