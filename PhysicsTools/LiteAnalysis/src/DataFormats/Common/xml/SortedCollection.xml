<?xml version="1.0"?>
<!--
==============================================================================
  XML File: SortedCollection.xml
  Created:  Fri Jan 15 20:45:58 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/SortedCollection.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/SortedCollection.h">

    <include name="&lt;algorithm&gt;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&quot;DataFormats/Common/interface/EDProduct.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/FillView.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/fillPtrVector.h&quot;"/>
    <include name="&quot;DataFormats/Provenance/interface/ProductID.h&quot;"/>
    <include name="&quot;FWCore/Utilities/interface/EDMException.h&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;T, SORT=StrictWeakOrdering&lt;T&gt; &gt;
    SortedCollection"/>

        <class name="has_fillView&lt;edm::SortedCollection&lt;T,SORT&gt; &gt;"
               fullname="edm::has_fillView&lt;edm::SortedCollection&lt;T,SORT&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class SORT&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;edm::SortedCollection&lt;T, SORT&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;edm::SortedCollection&lt;T,SORT&gt; &gt;"
               fullname="edm::has_setPtr&lt;edm::SortedCollection&lt;T,SORT&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class SORT&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_setPtr&lt;edm::SortedCollection&lt;T, SORT&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="StrictWeakOrdering"
               fullname="edm::StrictWeakOrdering&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <typedef name="key_type"
                         value="typename T::key_type">
typedef typename T::key_type key_type;
                </typedef>

                <operator name="operator()"
                          return="bool"
                          args="['key_type','T const&amp;']"
                          vars="['a','b']"
                          qual="const">
bool operatorPP(key_type a, T const&amp; b) const;
                    <comment>
       Each of the following comparisons are needed (at least with GCC's library).
                    </comment>
                </operator>

                <operator name="operator()"
                          return="bool"
                          args="['T const&amp;','key_type']"
                          vars="['a','b']"
                          qual="const">
bool operatorPP(T const&amp; a, key_type b) const;
                </operator>

                <operator name="operator()"
                          return="bool"
                          args="['T const&amp;','T const&amp;']"
                          vars="['a','b']"
                          qual="const">
bool operatorPP(T const&amp; a, T const&amp; b) const;
                </operator>

            </section>

            <typemap name="key_type"
                     value="typename T::key_type"
                     type="typedef"/>

        </class>

        <class name="SortedCollection"
               fullname="edm::SortedCollection&lt;T, SORT&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T, class SORT&gt;">

            <section name="public">
                <typedef name="value_type"
                         value="T">
typedef T value_type;
                </typedef>

                <typedef name="key_compare"
                         value="SORT">
typedef SORT key_compare;
                </typedef>

                <typedef name="const_iterator"
                         value="typename std::vector&lt;T&gt;::const_iterator">
typedef typename std::vector&lt;T&gt;::const_iterator const_iterator;
                </typedef>

                <typedef name="iterator"
                         value="typename std::vector&lt;T&gt;::iterator">
typedef typename std::vector&lt;T&gt;::iterator iterator;
                </typedef>

                <typedef name="const_reference"
                         value="typename std::vector&lt;T&gt;::const_reference">
typedef typename std::vector&lt;T&gt;::const_reference const_reference;
                </typedef>

                <typedef name="reference"
                         value="typename std::vector&lt;T&gt;::reference">
typedef typename std::vector&lt;T&gt;::reference reference;
                </typedef>

                <typedef name="size_type"
                         value="typename std::vector&lt;T&gt;::size_type">
typedef typename std::vector&lt;T&gt;::size_type size_type;
                </typedef>

                <typedef name="key_type"
                         value="typename key_compare::key_type">
typedef typename key_compare::key_type key_type;
                    <comment>
       This needs to be turned into a template parameter, perhaps with
       a default --- if there is a way to slip in the default without
       growing any dependence on the code supplying the key!
                    </comment>
                </typedef>

                <constructor name="SortedCollection"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
SortedCollection();
                </constructor>

                <constructor name="SortedCollection"
                             return="explicit"
                             args="['size_type']"
                             vars="['n']"
                             qual="">
explicit SortedCollection(size_type n);
                </constructor>

                <constructor name="SortedCollection"
                             return="explicit"
                             args="['std::vector&lt;T&gt; const&amp;']"
                             vars="['vec']"
                             qual="">
explicit SortedCollection(std::vector&lt;T&gt; const&amp; vec);
                </constructor>

                <copyconstructor name="SortedCollection"
                                 return=""
                                 args="['SortedCollection const&amp;']"
                                 vars="['h']"
                                 qual="">
SortedCollection(SortedCollection const&amp; h);
                </copyconstructor>

                <method1 name="push_back"
                         return="void"
                         args="['T const&amp;']"
                         vars="['t']"
                         qual="">
void push_back(T const&amp; t);
                    <comment>
       Add the following when needed
      template &lt;class InputIterator&gt;
      SortedCollection(InputIterator b, InputIterator e);
                    </comment>
                </method1>

                <method1 name="swap"
                         return="void"
                         args="['SortedCollection&amp;']"
                         vars="['other']"
                         qual="">
void swap(SortedCollection&amp; other);
                </method1>

                <method2 name="swap_contents"
                         return="void"
                         args="['std::vector&lt;T&gt;&amp;']"
                         vars="['other']"
                         qual="">
void swap_contents(std::vector&lt;T&gt;&amp; other);
                </method2>

                <operator name="operator="
                          return="SortedCollection&amp;"
                          args="['SortedCollection const&amp;']"
                          vars="['rhs']"
                          qual="">
SortedCollection&amp; operator=(SortedCollection const&amp; rhs);
                </operator>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                </method1>

                <method1 name="size"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type size() const;
                </method1>

                <method1 name="capacity"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type capacity() const;
                </method1>

                <method1 name="reserve"
                         return="void"
                         args="['size_type']"
                         vars="['n']"
                         qual="">
void reserve(size_type n);
                </method1>

                <operator name="operator[]"
                          return="reference"
                          args="['size_type']"
                          vars="['i']"
                          qual="">
reference operator[](size_type i);
                    <comment>
       Return a reference to the i'th item in the collection.
       Note that the argument is an *integer*, not an object of
         type key_type
                    </comment>
                </operator>

                <operator name="operator[]"
                          return="const_reference"
                          args="['size_type']"
                          vars="['i']"
                          qual="const">
const_reference operator[](size_type i) const;
                </operator>

                <method1 name="find"
                         return="iterator"
                         args="['key_type']"
                         vars="['k']"
                         qual="">
iterator find(key_type k);
                    <comment>
       Find the item with key matching k. If no such item is found,
       return end();
                    </comment>
                </method1>

                <method1 name="find"
                         return="const_iterator"
                         args="['key_type']"
                         vars="['k']"
                         qual="const">
const_iterator find(key_type k) const;
                </method1>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                </method1>

                <method1 name="begin"
                         return="iterator"
                         args="['void']"
                         vars="['']"
                         qual="">
iterator begin();
                </method1>

                <method1 name="end"
                         return="iterator"
                         args="['void']"
                         vars="['']"
                         qual="">
iterator end();
                </method1>

                <method1 name="front"
                         return="const_reference"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_reference front() const;
                </method1>

                <method1 name="front"
                         return="reference"
                         args="['void']"
                         vars="['']"
                         qual="">
reference front();
                </method1>

                <method1 name="back"
                         return="const_reference"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_reference back() const;
                </method1>

                <method1 name="back"
                         return="reference"
                         args="['void']"
                         vars="['']"
                         qual="">
reference back();
                </method1>

                <method1 name="sort"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void sort();
                    <comment>
       Sort the elements of the vector, in the order determined by the
       keys. Note that the Event will make sure to call this function
       after the SortedCollection has been put into the Event, so
       there is no need to call it in user code (unless one needs the
       collection sorted *before* it is inserted into the Event).
                    </comment>
                </method1>

                <method1 name="post_insert"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void post_insert();
                    <comment>
       This function will be called by the edm::Event after the
       SortedCollection has been inserted into the Event.
                    </comment>
                </method1>

                <method2 name="fillView"
                         return="void"
                         args="['ProductID const&amp;','std::vector&lt;void const*&gt;&amp;','helper_vector&amp;']"
                         vars="['id','pointers','helpers']"
                         qual="const">
void fillView(ProductID const&amp; id, std::vector&lt;void const*&gt;&amp; pointers, helper_vector&amp; helpers) const;
                </method2>

                <method1 name="setPtr"
                         return="void"
                         args="['std::type_info const&amp;','unsigned long','void const*&amp;']"
                         vars="['toType','index','ptr']"
                         qual="const">
void setPtr(std::type_info const&amp; toType, unsigned long index, void const*&amp; ptr) const;
                </method1>

                <method2 name="fillPtrVector"
                         return="void"
                         args="['const std::type_info&amp;','const std::vector&lt;unsigned long&gt;&amp;','std::vector&lt;void const*&gt;&amp;']"
                         vars="['toType','indices','ptrs']"
                         qual="const">
void fillPtrVector(const std::type_info&amp; toType, const std::vector&lt;unsigned long&gt;&amp; indices, std::vector&lt;void const*&gt;&amp; ptrs) const;
                </method2>

            </section>

            <typemap name="const_iterator"
                     value="typename std::vector&lt;T&gt;::const_iterator"
                     type="typedef"/>
            <typemap name="const_reference"
                     value="typename std::vector&lt;T&gt;::const_reference"
                     type="typedef"/>
            <typemap name="iterator"
                     value="typename std::vector&lt;T&gt;::iterator"
                     type="typedef"/>
            <typemap name="key_compare"
                     value="SORT"
                     type="typedef"/>
            <typemap name="key_type"
                     value="typename SORT::key_type"
                     type="typedef"/>
            <typemap name="reference"
                     value="typename std::vector&lt;T&gt;::reference"
                     type="typedef"/>
            <typemap name="size_type"
                     value="typename std::vector&lt;T&gt;::size_type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="T"
                     type="typedef"/>

        </class>
    </namespace>

    <type name="ProductID const&amp;"/>
    <type name="SortedCollection const&amp;"/>
    <type name="SortedCollection&amp;"/>
    <type name="bool"/>
    <type name="bool const value"/>
    <type name="const std::type_info&amp;"/>
    <type name="const std::vector&lt;unsigned long&gt;&amp;"/>
    <type name="const_iterator"/>
    <type name="const_reference"/>
    <type name="edm::SortedCollection&lt;T, SORT&gt;"/>
    <type name="edm::StrictWeakOrdering&lt;T&gt;"/>
    <type name="edm::has_fillView&lt;edm::SortedCollection&lt;T, SORT&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;edm::SortedCollection&lt;T, SORT&gt; &gt;"/>
    <type name="helper_vector&amp;"/>
    <type name="iterator"/>
    <type name="key_type"/>
    <type name="reference"/>
    <type name="size_type"/>
    <type name="std::type_info const&amp;"/>
    <type name="std::vector&lt;T&gt; const&amp;"/>
    <type name="std::vector&lt;T&gt;&amp;"/>
    <type name="std::vector&lt;void const*&gt;&amp;"/>
    <type name="unsigned long"/>
    <type name="void"/>
    <type name="void const*&amp;"/>
</header>
