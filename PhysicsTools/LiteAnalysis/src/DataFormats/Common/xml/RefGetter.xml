<?xml version="1.0"?>
<!--
==============================================================================
  XML File: RefGetter.xml
  Created:  Thu Jan 14 22:46:18 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/RefGetter.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/RefGetter.h">

    <include name="&lt;algorithm&gt;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&lt;iostream&gt;"/>
    <include name="&lt;utility&gt;"/>
    <include name="&quot;boost/concept_check.hpp&quot;"/>
    <include name="&quot;boost/iterator/indirect_iterator.hpp&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Handle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/LazyGetter.h&quot;"/>
    <include name="&quot;FWCore/Utilities/interface/EDMException.h&quot;"/>

    <namespace name="edm">

        <class name="RefGetter"
               fullname="edm::RefGetter&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">

            <section>
                <constructor name="BOOST_CLASS_REQUIRE"
                             return=""
                             args="['T','boost','LessThanComparableConcept']"
                             vars="['','','']"
                             qual="">
BOOST_CLASS_REQUIRE(T, boost, LessThanComparableConcept);
                </constructor>

            </section>
            <section name="public">
                <typedef name="region_ref"
                         value="Ref&lt;LazyGetter&lt;T&gt;, RegionIndex&lt;T&gt;, FindRegion&lt;T&gt; &gt;">
typedef Ref&lt;LazyGetter&lt;T&gt;, RegionIndex&lt;T&gt;, FindRegion&lt;T&gt; &gt; region_ref;
                </typedef>

                <typedef name="collection_type"
                         value="std::vector&lt;region_ref&gt;">
typedef std::vector&lt;region_ref&gt; collection_type;
                </typedef>

                <typedef name="const_iterator"
                         value="boost::indirect_iterator&lt;typename collection_type::const_iterator&gt;">
typedef boost::indirect_iterator&lt;typename collection_type::const_iterator&gt; const_iterator;
                </typedef>

                <typedef name="record_type"
                         value="std::vector&lt;T&gt;">
typedef std::vector&lt;T&gt; record_type;
                </typedef>

                <typedef name="record_pair"
                         value="std::pair&lt;typename record_type::const_iterator, typename record_type::const_iterator&gt;">
typedef std::pair&lt;typename record_type::const_iterator, typename record_type::const_iterator&gt; record_pair;
                </typedef>

                <constructor name="RefGetter"
                             return=""
                             args="['uint32_t=50000']"
                             vars="['']"
                             qual="">
RefGetter(uint32_t=50000);
                    <comment>
        Default constructor. Default maximum region number 50,000.
                    </comment>
                </constructor>

                <constructor name="RefGetter"
                             return=""
                             args="['const edm::Handle&lt;LazyGetter&lt;T&gt; &gt;&amp;','const std::vector&lt;uint32_t&gt;&amp;']"
                             vars="['','']"
                             qual="">
RefGetter(const edm::Handle&lt;LazyGetter&lt;T&gt; &gt;&amp;, const std::vector&lt;uint32_t&gt;&amp;);
                    <comment>
        Constructor with regions and Handle
                    </comment>
                </constructor>

                <method1 name="reserve"
                         return="void"
                         args="['uint32_t']"
                         vars="['']"
                         qual="">
void reserve(uint32_t);
                    <comment>
        Reserve memory for sets_ collection.
                    </comment>
                </method1>

                <method1 name="swap"
                         return="void"
                         args="['RefGetter&amp;']"
                         vars="['other']"
                         qual="">
void swap(RefGetter&amp; other);
                    <comment>
        Swap contents of class.
                    </comment>
                </method1>

                <method2 name="push_back"
                         return="void"
                         args="['const edm::Handle&lt;LazyGetter&lt;T&gt; &gt;&amp;','const uint32_t&amp;']"
                         vars="['','']"
                         qual="">
void push_back(const edm::Handle&lt;LazyGetter&lt;T&gt; &gt;&amp;, const uint32_t&amp;);
                    <comment>
        Add a new region to the end of the collection.
                    </comment>
                </method2>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                    <comment>
        Return true if we contain no 'region_ref's (one per Region).
                    </comment>
                </method1>

                <method1 name="size"
                         return="uint32_t"
                         args="['void']"
                         vars="['']"
                         qual="const">
uint32_t size() const;
                    <comment>
        Return the number of contained 'region_ref's (one per Region).
                    </comment>
                </method1>

                <operator name="operator[]"
                          return="const RegionIndex&lt;T&gt;&amp;"
                          args="['uint32_t']"
                          vars="['']"
                          qual="const">
const RegionIndex&lt;T&gt;&amp; operator[](uint32_t) const;
                    <comment>
        Return a reference to the RegionIndex&lt;T&gt; for a given region.
                    </comment>
                </operator>

                <method2 name="back"
                         return="const RegionIndex&lt;T&gt;&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const RegionIndex&lt;T&gt;&amp; back() const;
                    <comment>
        collection, or throws an exception if empty.
                    </comment>
                </method2>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                    <comment>
        Return an iterator to the first RegionIndex&lt;T&gt;.
                    </comment>
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                    <comment>
        Return the off-the-end iterator.
                    </comment>
                </method1>

                <method1 name="find"
                         return="bool"
                         args="['uint32_t']"
                         vars="['']"
                         qual="const">
bool find(uint32_t) const;
                    <comment>
        Returns true if region already defined.
                    </comment>
                </method1>

            </section>

            <typemap name="collection_type"
                     value="std::vector&lt;Ref&lt;LazyGetter&lt;T&gt;, RegionIndex&lt;T&gt;, FindRegion&lt;T&gt; &gt; &gt;"
                     type="typedef"/>
            <typemap name="const_iterator"
                     value="typename boost::indirect_iterator&lt;typename std::vector&lt;Ref&lt;LazyGetter&lt;T&gt;, RegionIndex&lt;T&gt;, FindRegion&lt;T&gt; &gt; &gt;::const_iterator&gt;"
                     type="typedef"/>
            <typemap name="record_pair"
                     value="typename std::pair&lt;typename std::vector&lt;T&gt;::const_iterator, typename std::vector&lt;T&gt;::const_iterator&gt;"
                     type="typedef"/>
            <typemap name="record_type"
                     value="std::vector&lt;T&gt;"
                     type="typedef"/>
            <typemap name="region_ref"
                     value="Ref&lt;LazyGetter&lt;T&gt;, RegionIndex&lt;T&gt;, FindRegion&lt;T&gt; &gt;"
                     type="typedef"/>

        </class>
    </namespace>

    <type name="LessThanComparableConcept"/>
    <type name="RefGetter&amp;"/>
    <type name="bool"/>
    <type name="boost"/>
    <type name="const RegionIndex&lt;T&gt;&amp;"/>
    <type name="const edm::Handle&lt;LazyGetter&lt;T&gt; &gt;&amp;"/>
    <type name="const std::vector&lt;uint32_t&gt;&amp;"/>
    <type name="const uint32_t&amp;"/>
    <type name="const_iterator"/>
    <type name="edm::RefGetter&lt;T&gt;"/>
    <type name="uint32_t"/>
    <type name="void"/>
</header>
