<?xml version="1.0"?>
<!--
==============================================================================
  XML File: traits.xml
  Created:  Fri Jan 15 20:46:04 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/traits.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/traits.h">

    <include name="&lt;deque&gt;"/>
    <include name="&lt;limits&gt;"/>
    <include name="&lt;list&gt;"/>
    <include name="&lt;map&gt;"/>
    <include name="&lt;set&gt;"/>
    <include name="&lt;string&gt;"/>
    <include name="&lt;utility&gt;"/>
    <include name="&lt;vector&gt;"/>

    <namespace name="edm">

        <class name="key_traits"
               fullname="edm::key_traits&lt;K&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class K&gt;">
            <comment>
     The trait struct template key_traits&lt;K&gt; is used to carry
     information relevant to the type K when used as a 'key' in
     RefVector and its related classes and templates.

     The general case works only for integral types K; for more
     'esoteric' types, one must introduce an explicit specialization.
     That specialization must initialize the static data member
     'value'.
            </comment>

            <section>
                <typedef name="key_type"
                         value="K">
typedef K key_type;
                </typedef>

                <constant name="value"
                          type="static const key_type"
                          value=""/>
            </section>

            <typemap name="key_type"
                     value="K"
                     type="typedef"/>

        </class>

        <class name="key_traits&lt;std::pair&lt;U,V&gt; &gt;"
               fullname="edm::key_traits&lt;std::pair&lt;U,V&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class U, class V&gt;">
            <comment>
     Partial specialization for std::pair
            </comment>

            <section>
                <typedef name="key_type"
                         value="std::pair&lt;U, V&gt;">
typedef std::pair&lt;U, V&gt; key_type;
                </typedef>

                <constant name="value"
                          type="static const key_type"
                          value=""/>
            </section>

            <typemap name="key_type"
                     value="std::pair&lt;U, V&gt;"
                     type="typedef"/>

        </class>

        <class name="key_traits&lt;std::string&gt;"
               fullname="edm::key_traits&lt;std::string&gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template struct"
               template="template&lt;&gt;">
            <comment>
     For value, we make a 1-character long string that contains an
     unprintable character; we are hoping nobody ever uses such a
     string as a legal key.
            </comment>

            <section>
                <typedef name="key_type"
                         value="std::string">
typedef std::string key_type;
                </typedef>

                <constant name="value"
                          type="static const key_type"
                          value=""/>
            </section>

            <typemap name="key_type"
                     value="std::string"
                     type="typedef"/>

        </class>

        <class name="DoNotSortUponInsertion"
               fullname="edm::DoNotSortUponInsertion"
               module="DataFormats.Common"
               project=""
               type="regular struct">
            <comment>
     DoNotSortUponInsertion is a base class. Derive your own class X
     from DoNotSortUponInsertion when:

     1. You want to use DetSetVector&lt;X&gt; as an EDProduct, but

     2. You do *not* want the Event::put member template to cause the
     DetSet&lt;X&gt; instances within the DetSetVector&lt;X&gt; to be sorted.

     DoNotSortUponInsertion has no behavior; it is used at compile
     time to influence the behavior of Event::put.

     Usage:
        class MyClass : public edm::DoNotSortUponInsertion { ... }
            </comment>


        </class>

        <class name="DoNotRecordParents"
               fullname="edm::DoNotRecordParents"
               module="DataFormats.Common"
               project=""
               type="regular struct">
            <comment>
     DoNotRecordParents is a base class. Derive your own (EDProduct)
     class X from DoNotRecordParents when your class already keeps all
     data that are relevant to parentage internally, and the
     information kept by the event model would thus be redundant.

     DoNotRecordParents has no behavior; it is used at compile time to
     influence the behavior of Event::put.

     Usage:
        class MyClass : public edm::DoNotRecordParents { ... }
            </comment>


        </class>

        <class name="Other"
               fullname="edm::Other"
               module="DataFormats.Common"
               project=""
               type="regular struct">
            <comment>
     Other is a base class. NEVER USE IT. It is for the
     core of the event model only.
            </comment>


        </class>

        <class name="has_fillView"
               fullname="edm::has_fillView&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">
            <comment>
     The trait struct template has_fillView&lt;T&gt; is used to
     indicate whether or not the type T has a member function

          void T::fillView(std::vector&lt;void const*&gt;&amp;) const

     We assume the 'general case' for T is to not support fillView.
     Classes which do support fillView must specialize this trait.
            </comment>

            <section>
                <member>
static bool const value=false;
                </member>

            </section>

            <typemap name="false"
                     value="edm::has_fillView&lt;T&gt;::false"
                     type="member"/>

        </class>

        <class name="has_fillView&lt;std::vector&lt;T,A&gt; &gt;"
               fullname="edm::has_fillView&lt;std::vector&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;std::vector&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_fillView&lt;std::vector&lt;bool,A&gt; &gt;"
               fullname="edm::has_fillView&lt;std::vector&lt;bool,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class A&gt;">

            <section>
                <member>
static bool const value=false;
                </member>

            </section>

            <typemap name="false"
                     value="edm::has_fillView&lt;std::vector&lt;bool, A&gt; &gt;::false"
                     type="member"/>

        </class>

        <class name="has_fillView&lt;std::list&lt;T,A&gt; &gt;"
               fullname="edm::has_fillView&lt;std::list&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;std::list&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_fillView&lt;std::deque&lt;T,A&gt; &gt;"
               fullname="edm::has_fillView&lt;std::deque&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;std::deque&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_fillView&lt;std::set&lt;T,A&gt; &gt;"
               fullname="edm::has_fillView&lt;std::set&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_fillView&lt;std::set&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_setPtr"
               fullname="edm::has_setPtr&lt;T&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;class T&gt;">
            <comment>
     The trait struct template has_setPtr&lt;T&gt; is used to
     indicate whether or not the type T has a member function

          void T::setPtr(const std::type_info&amp;, void const*&amp;) const

     We assume the 'general case' for T is to not support setPtr.
     Classes which do support setPtr must specialize this trait.
            </comment>

            <section>
                <member>
static bool const value=false;
                </member>

            </section>

            <typemap name="false"
                     value="edm::has_setPtr&lt;T&gt;::false"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;std::vector&lt;T,A&gt; &gt;"
               fullname="edm::has_setPtr&lt;std::vector&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_setPtr&lt;std::vector&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;std::vector&lt;bool,A&gt; &gt;"
               fullname="edm::has_setPtr&lt;std::vector&lt;bool,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class A&gt;">

            <section>
                <member>
static bool const value=false;
                </member>

            </section>

            <typemap name="false"
                     value="edm::has_setPtr&lt;std::vector&lt;bool, A&gt; &gt;::false"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;std::list&lt;T,A&gt; &gt;"
               fullname="edm::has_setPtr&lt;std::list&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_setPtr&lt;std::list&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;std::deque&lt;T,A&gt; &gt;"
               fullname="edm::has_setPtr&lt;std::deque&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_setPtr&lt;std::deque&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>

        <class name="has_setPtr&lt;std::set&lt;T,A&gt; &gt;"
               fullname="edm::has_setPtr&lt;std::set&lt;T,A&gt; &gt;"
               module="DataFormats.Common"
               project=""
               type="specialized template"
               template="template&lt;class T, class A&gt;">

            <section>
                <member>
static bool const value=true;
                </member>

            </section>

            <typemap name="true"
                     value="edm::has_setPtr&lt;std::set&lt;T, A&gt; &gt;::true"
                     type="member"/>

        </class>
    </namespace>

    <type name="bool const value"/>
    <type name="edm::DoNotRecordParents"/>
    <type name="edm::DoNotSortUponInsertion"/>
    <type name="edm::Other"/>
    <type name="edm::has_fillView&lt;T&gt;"/>
    <type name="edm::has_fillView&lt;std::deque&lt;T, A&gt; &gt;"/>
    <type name="edm::has_fillView&lt;std::list&lt;T, A&gt; &gt;"/>
    <type name="edm::has_fillView&lt;std::set&lt;T, A&gt; &gt;"/>
    <type name="edm::has_fillView&lt;std::vector&lt;T, A&gt; &gt;"/>
    <type name="edm::has_fillView&lt;std::vector&lt;bool, A&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;T&gt;"/>
    <type name="edm::has_setPtr&lt;std::deque&lt;T, A&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;std::list&lt;T, A&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;std::set&lt;T, A&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;std::vector&lt;T, A&gt; &gt;"/>
    <type name="edm::has_setPtr&lt;std::vector&lt;bool, A&gt; &gt;"/>
    <type name="edm::key_traits&lt;K&gt;"/>
    <type name="edm::key_traits&lt;std::pair&lt;U, V&gt; &gt;"/>
    <type name="edm::key_traits&lt;std::string&gt;"/>
</header>
