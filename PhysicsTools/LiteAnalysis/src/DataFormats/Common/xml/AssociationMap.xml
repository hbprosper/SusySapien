<?xml version="1.0"?>
<!--
==============================================================================
  XML File: AssociationMap.xml
  Created:  Thu Jan 14 22:45:48 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/AssociationMap.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_2_2_13/src/DataFormats/Common/interface/AssociationMap.h">

    <include name="&quot;DataFormats/Common/interface/RefVector.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OneToValue.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OneToOne.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OneToMany.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OneToManyWithQuality.h&quot;"/>

    <namespace name="edm">

        <class name="AssociationMap"
               fullname="edm::AssociationMap&lt;Tag&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename Tag&gt;">

            <section>
                <typedef name="internal_val_type"
                         value="typename Tag::val_type">
typedef typename Tag::val_type internal_val_type;
                    <comment>
        insert key type
                    </comment>
                </typedef>

            </section>
            <section name="public">
                <typedef name="self"
                         value="AssociationMap&lt;Tag&gt;">
typedef AssociationMap&lt;Tag&gt; self;
                    <comment>
        self type
                    </comment>
                </typedef>

                <typedef name="index_type"
                         value="typename Tag::index_type">
typedef typename Tag::index_type index_type;
                    <comment>
        index type
                    </comment>
                </typedef>

                <typedef name="key_type"
                         value="typename Tag::key_type">
typedef typename Tag::key_type key_type;
                    <comment>
        insert key type
                    </comment>
                </typedef>

                <typedef name="data_type"
                         value="typename Tag::data_type">
typedef typename Tag::data_type data_type;
                    <comment>
        insert data type
                    </comment>
                </typedef>

                <typedef name="ref_type"
                         value="typename Tag::ref_type">
typedef typename Tag::ref_type ref_type;
                    <comment>
        reference set type
                    </comment>
                </typedef>

                <typedef name="map_type"
                         value="typename Tag::map_type">
typedef typename Tag::map_type map_type;
                    <comment>
        map type
                    </comment>
                </typedef>

                <typedef name="size_type"
                         value="typename map_type::size_type">
typedef typename map_type::size_type size_type;
                    <comment>
        size type
                    </comment>
                </typedef>

                <typedef name="value_type"
                         value="helpers::KeyVal&lt;key_type, internal_val_type&gt;">
typedef helpers::KeyVal&lt;key_type, internal_val_type&gt; value_type;
                    <comment>
        value type
                    </comment>
                </typedef>

                <typedef name="result_type"
                         value="typename value_type::value_type">
typedef typename value_type::value_type result_type;
                    <comment>
        result type
                    </comment>
                </typedef>

                <typedef name="internal_transient_map_type"
                         value="typename std::map&lt;index_type, value_type&gt;">
typedef typename std::map&lt;index_type, value_type&gt; internal_transient_map_type;
                    <comment>
        transient map type
                    </comment>
                </typedef>


                <class name="const_iterator"
                       fullname="edm::AssociationMap&lt;Tag&gt;::const_iterator"
                       module="DataFormats.Common"
                       project=""
                       type="regular struct">
                    <comment>
        const iterator
                    </comment>

                    <section>
                        <typedef name="value_type"
                                 value="typename self::value_type">
typedef typename self::value_type value_type;
                        </typedef>

                        <typedef name="difference_type"
                                 value="ptrdiff_t">
typedef ptrdiff_t difference_type;
                        </typedef>

                        <typedef name="pointer"
                                 value="value_type*">
typedef value_type* pointer;
                        </typedef>

                        <typedef name="reference"
                                 value="value_type&amp;">
typedef value_type&amp; reference;
                        </typedef>

                        <typedef name="iterator_category"
                                 value="typename map_type::const_iterator::iterator_category">
typedef typename map_type::const_iterator::iterator_category iterator_category;
                        </typedef>

                        <constructor name="const_iterator"
                                     return=""
                                     args="['void']"
                                     vars="['']"
                                     qual="">
const_iterator();
                        </constructor>

                        <constructor name="const_iterator"
                                     return=""
                                     args="['const self*','typename map_type::const_iterator']"
                                     vars="['map','mi']"
                                     qual="">
const_iterator(const self* map, typename map_type::const_iterator mi);
                        </constructor>

                        <operator name="operator="
                                  return="const_iterator&amp;"
                                  args="['const const_iterator&amp;']"
                                  vars="['it']"
                                  qual="">
const_iterator&amp; operator=(const const_iterator&amp; it);
                        </operator>

                        <operator name="operator++"
                                  return="const_iterator&amp;"
                                  args="['void']"
                                  vars="['']"
                                  qual="">
const_iterator&amp; operator++();
                        </operator>

                        <operator name="operator++"
                                  return="const_iterator"
                                  args="['int']"
                                  vars="['']"
                                  qual="">
const_iterator operator++(int);
                        </operator>

                        <operator name="operator--"
                                  return="const_iterator&amp;"
                                  args="['void']"
                                  vars="['']"
                                  qual="">
const_iterator&amp; operator--();
                        </operator>

                        <operator name="operator--"
                                  return="const_iterator"
                                  args="['int']"
                                  vars="['']"
                                  qual="">
const_iterator operator--(int);
                        </operator>

                        <operator name="operator=="
                                  return="bool"
                                  args="['const const_iterator&amp;']"
                                  vars="['ci']"
                                  qual="const">
bool operator==(const const_iterator&amp; ci) const;
                        </operator>

                        <operator name="operator!="
                                  return="bool"
                                  args="['const const_iterator&amp;']"
                                  vars="['ci']"
                                  qual="const">
bool operator!=(const const_iterator&amp; ci) const;
                        </operator>

                        <operator name="operator*"
                                  return="const value_type&amp;"
                                  args="['void']"
                                  vars="['']"
                                  qual="const">
const value_type&amp; operator*() const;
                        </operator>

                        <operator name="operator-&gt;"
                                  return="const value_type*"
                                  args="['void']"
                                  vars="['']"
                                  qual="const">
const value_type* operator-&gt;() const;
                        </operator>

                    </section>
                    <section name="private">
                        <constant name="map_"
                                  type="const self*"
                                  value=""/>
                    </section>

                    <typemap name="const_iterator"
                             value="edm::AssociationMap&lt;Tag&gt;::const_iterator"
                             type="class"/>
                    <typemap name="difference_type"
                             value="ptrdiff_t"
                             type="typedef"/>
                    <typemap name="iterator_category"
                             value="typename map_type::const_iterator::iterator_category"
                             type="typedef"/>
                    <typemap name="pointer"
                             value="typename self::value_type*"
                             type="typedef"/>
                    <typemap name="reference"
                             value="typename self::value_type&amp;"
                             type="typedef"/>
                    <typemap name="value_type"
                             value="typename self::value_type"
                             type="typedef"/>

                </class>
                <constructor name="AssociationMap"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
AssociationMap();
                    <comment>
        default constructor
                    </comment>
                </constructor>

                <method1 name="AssociationMap"
                         return="explicit"
                         args="['const ref_type&amp;']"
                         vars="['ref']"
                         qual="">
explicit     AssociationMap(const ref_type&amp; ref);
                    <comment>
        default constructor
                    </comment>
                </method1>

                <method1 name="clear"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void clear();
                    <comment>
        clear map
                    </comment>
                </method1>

                <method1 name="size"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type size() const;
                    <comment>
        map size
                    </comment>
                </method1>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                    <comment>
        return true if empty
                    </comment>
                </method1>

                <method1 name="insert"
                         return="void"
                         args="['const key_type&amp;','const data_type&amp;']"
                         vars="['k','v']"
                         qual="">
void insert(const key_type&amp; k, const data_type&amp; v);
                    <comment>
        insert an association
                    </comment>
                </method1>

                <method1 name="insert"
                         return="void"
                         args="['const value_type&amp;']"
                         vars="['kv']"
                         qual="">
void insert(const value_type&amp; kv);
                </method1>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                    <comment>
        first iterator over the map (read only)
                    </comment>
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                    <comment>
        last iterator over the map (read only)
                    </comment>
                </method1>

                <method1 name="find"
                         return="const_iterator"
                         args="['const key_type&amp;']"
                         vars="['k']"
                         qual="const">
const_iterator find(const key_type&amp; k) const;
                    <comment>
        find element with specified reference key
                    </comment>
                </method1>

                <method1 name="erase"
                         return="size_type"
                         args="['const key_type&amp;']"
                         vars="['k']"
                         qual="">
size_type erase(const key_type&amp; k);
                    <comment>
        erase the element whose key is k
                    </comment>
                </method1>

                <operator name="operator[]"
                          return="const result_type&amp;"
                          args="['const key_type&amp;']"
                          vars="['k']"
                          qual="const">
const result_type&amp; operator[](const key_type&amp; k) const;
                    <comment>
        find element with specified reference key
                    </comment>
                </operator>

                <method1 name="numberOfAssociations"
                         return="size_type"
                         args="['const key_type&amp;']"
                         vars="['k']"
                         qual="const">
size_type numberOfAssociations(const key_type&amp; k) const;
                    <comment>
        number of associations to a key
                    </comment>
                </method1>

                <method1 name="refProd"
                         return="const ref_type&amp;"
                         args="['void']"
                         vars="['']"
                         qual="const">
const ref_type&amp; refProd() const;
                    <comment>
        return ref-prod structure
                    </comment>
                </method1>

                <method1 name="map"
                         return="typename Tag::transient_map_type"
                         args="['void']"
                         vars="['']"
                         qual="">
typename Tag::transient_map_type map();
                    <comment>
        required for ROOT interactive usage
                    </comment>
                </method1>

                <method1 name="keys"
                         return="typename Tag::transient_key_vector"
                         args="['void']"
                         vars="['']"
                         qual="">
typename Tag::transient_key_vector keys();
                    <comment>
        required for ROOT interactive usage
                    </comment>
                </method1>

                <method1 name="values"
                         return="typename Tag::transient_val_vector"
                         args="['void']"
                         vars="['']"
                         qual="">
typename Tag::transient_val_vector values();
                    <comment>
        required for ROOT interactive usage
                    </comment>
                </method1>

                <method1 name="post_insert"
                         return="void"
                         args="['void']"
                         vars="['']"
                         qual="">
void post_insert();
                    <comment>
         post insert action
                    </comment>
                </method1>


                <class name="Find"
                       fullname="edm::AssociationMap&lt;Tag&gt;::Find"
                       module="DataFormats.Common"
                       project=""
                       type="regular struct">
                    <baseclass name="public std::binary_function&lt;const self&amp;, size_type, const value_type*&gt;"/>
                    <comment>
        find helper
                    </comment>

                    <section>
                        <typedef name="self"
                                 value="Find">
typedef Find self;
                        </typedef>

                        <operator name="operator()"
                                  return="const value_type*"
                                  args="['typename self::first_argument_type','typename self::second_argument_type']"
                                  vars="['c','i']"
                                  qual="">
const value_type* operatorPP(typename self::first_argument_type c, typename self::second_argument_type i);
                        </operator>

                    </section>

                    <typemap name="Find"
                             value="edm::AssociationMap&lt;Tag&gt;::Find"
                             type="class"/>
                    <typemap name="self"
                             value="Find"
                             type="typedef"/>

                </class>
            </section>

            <typemap name="data_type"
                     value="typename Tag::data_type"
                     type="typedef"/>
            <typemap name="index_type"
                     value="typename Tag::index_type"
                     type="typedef"/>
            <typemap name="internal_transient_map_type"
                     value="typename std::map&lt;typename Tag::index_type, helpers::KeyVal&lt;typename Tag::key_type, typename Tag::val_type&gt; &gt;"
                     type="typedef"/>
            <typemap name="internal_val_type"
                     value="typename Tag::val_type"
                     type="typedef"/>
            <typemap name="key_type"
                     value="typename Tag::key_type"
                     type="typedef"/>
            <typemap name="map_type"
                     value="typename Tag::map_type"
                     type="typedef"/>
            <typemap name="ref_type"
                     value="typename Tag::ref_type"
                     type="typedef"/>
            <typemap name="result_type"
                     value="typename helpers::KeyVal&lt;typename Tag::key_type, typename Tag::val_type&gt;::helpers::KeyVal&lt;typename Tag::key_type, typename Tag::val_type&gt;"
                     type="typedef"/>
            <typemap name="self"
                     value="AssociationMap&lt;Tag&gt;"
                     type="typedef"/>
            <typemap name="size_type"
                     value="typename typename Tag::map_type::size_type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="helpers::KeyVal&lt;typename Tag::key_type, typename Tag::val_type&gt;"
                     type="typedef"/>

        </class>

        <namespace name="refhelper">

            <class name="FindTrait&lt;AssociationMap&lt;Tag&gt;,
       typename AssociationMap&lt;Tag&gt;::value_type&gt;"
                   fullname="edm::refhelper::FindTrait&lt;AssociationMap&lt;Tag&gt;,
       typename AssociationMap&lt;Tag&gt;::value_type&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename Tag&gt;">

                <section>
                    <typedef name="value"
                             value="typename AssociationMap&lt;Tag&gt;::Find">
typedef typename AssociationMap&lt;Tag&gt;::Find value;
                    </typedef>

                </section>

                <typemap name="value"
                         value="typename AssociationMap&lt;Tag&gt;::Find"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="bool"/>
    <type name="const const_iterator&amp;"/>
    <type name="const data_type&amp;"/>
    <type name="const key_type&amp;"/>
    <type name="const ref_type&amp;"/>
    <type name="const result_type&amp;"/>
    <type name="const self*"/>
    <type name="const value_type&amp;"/>
    <type name="const value_type*"/>
    <type name="const_iterator"/>
    <type name="const_iterator&amp;"/>
    <type name="edm::AssociationMap&lt;Tag&gt;"/>
    <type name="edm::AssociationMap&lt;Tag&gt;::Find"/>
    <type name="edm::AssociationMap&lt;Tag&gt;::const_iterator"/>
    <type name="edm::refhelper::FindTrait&lt;AssociationMap&lt;Tag&gt;, 
       typename AssociationMap&lt;Tag&gt;::value_type&gt;"/>
    <type name="int"/>
    <type name="size_type"/>
    <type name="std::binary_function&lt;const self&amp;, size_type, const value_type*&gt;"/>
    <type name="typename Tag::transient_key_vector"/>
    <type name="typename Tag::transient_map_type"/>
    <type name="typename Tag::transient_val_vector"/>
    <type name="typename map_type::const_iterator"/>
    <type name="typename self::first_argument_type"/>
    <type name="typename self::second_argument_type"/>
    <type name="void"/>
</header>
