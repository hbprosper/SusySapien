<?xml version="1.0"?>
<!--
==============================================================================
  XML File: DetSetRefVector.xml
  Created:  Fri Jan 15 20:45:30 2010 with header2xml.py 1.13
==============================================================================
-->
<header name="DataFormats/Common/interface/DetSetRefVector.h"
        file="/home/harry/Desktop/cmssw/slc4_ia32_gcc345/cms/cmssw/CMSSW_3_3_6/src/DataFormats/Common/interface/DetSetRefVector.h">

    <include name="&lt;algorithm&gt;"/>
    <include name="&lt;vector&gt;"/>
    <include name="&quot;boost/concept_check.hpp&quot;"/>
    <include name="&quot;boost/iterator/indirect_iterator.hpp&quot;"/>
    <include name="&quot;DataFormats/Common/interface/traits.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/DetSet.h&quot;"/>
    <include name="&quot;FWCore/Utilities/interface/EDMException.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Ref.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/DetSetVector.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/Handle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/OrphanHandle.h&quot;"/>
    <include name="&quot;DataFormats/Common/interface/TestHandle.h&quot;"/>

    <namespace name="edm">
        <forward name="template&lt;typename T, typename C&gt; DetSetRefVector"/>

        <namespace name="dsrvdetail">
            <comment>
     Helper function, to regularize throwing of exceptions.
            </comment>
            <function1 name="_throw_range"
                       return="inline void"
                       args="['det_id_type']"
                       vars="['i']"
                       qual="">
inline     void _throw_range(det_id_type i);
                <comment>
       Throw an edm::Exception with an appropriate message
                </comment>
            </function1>

        </namespace>

        <namespace name="refhelper">

            <class name="FindDetSetForDetSetVector"
                   fullname="edm::refhelper::FindDetSetForDetSetVector&lt;T, C&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T, typename C &gt;">
                <baseclass name="public std::binary_function&lt;const C&amp;, edm::det_id_type, const DetSet&lt;T&gt;*&gt;"/>

                <section>
                    <typedef name="self"
                             value="FindDetSetForDetSetVector&lt;T, C&gt;">
typedef FindDetSetForDetSetVector&lt;T, C&gt; self;
                    </typedef>

                    <operator name="operator()"
                              return="typename self::result_type"
                              args="['typename self::first_argument_type','typename self::second_argument_type']"
                              vars="['iContainer','iIndex']"
                              qual="const">
typename self::result_type operatorPP(typename self::first_argument_type iContainer, typename self::second_argument_type iIndex) const;
                    </operator>

                </section>

                <typemap name="self"
                         value="FindDetSetForDetSetVector&lt;T, C&gt;"
                         type="typedef"/>

            </class>
        </namespace>

        <class name="CompareRefDetSet"
               fullname="edm::CompareRefDetSet&lt;T, C&gt;"
               module="DataFormats.Common"
               project=""
               type="template struct"
               template="template&lt;typename T, typename C=DetSetVector&lt;T&gt; &gt;">
            <comment>
    allow comparison of edm::Ref&lt;...&gt; to the det_it_type.  This allows searching without dereferencing the edm::Ref
            </comment>

            <section>
                <typedef name="ref_type"
                         value="Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt;">
typedef Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt; ref_type;
                </typedef>

                <operator name="operator()"
                          return="bool"
                          args="['const ref_type&amp;','det_id_type']"
                          vars="['iRef','iId']"
                          qual="">
bool operatorPP(const ref_type&amp; iRef, det_id_type iId);
                </operator>

                <operator name="operator()"
                          return="bool"
                          args="['det_id_type','const ref_type&amp;']"
                          vars="['iId','iRef']"
                          qual="">
bool operatorPP(det_id_type iId, const ref_type&amp; iRef);
                </operator>

            </section>

            <typemap name="ref_type"
                     value="Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt;"
                     type="typedef"/>

        </class>

        <class name="DetSetRefVector"
               fullname="edm::DetSetRefVector&lt;T, C&gt;"
               module="DataFormats.Common"
               project=""
               type="template"
               template="template&lt;typename T, typename C=DetSetVector&lt;T&gt; &gt;">

            <section>
                <constructor name="BOOST_CLASS_REQUIRE"
                             return=""
                             args="['T','boost','LessThanComparableConcept']"
                             vars="['','','']"
                             qual="">
BOOST_CLASS_REQUIRE(T, boost, LessThanComparableConcept);
                    <comment>
        operator&lt;.
                    </comment>
                </constructor>

            </section>
            <section name="public">
                <typedef name="detset"
                         value="DetSet&lt;T&gt;">
typedef DetSet&lt;T&gt; detset;
                </typedef>

                <typedef name="value_type"
                         value="detset">
typedef detset value_type;
                </typedef>

                <typedef name="ref_type"
                         value="Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt;">
typedef Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt; ref_type;
                </typedef>

                <typedef name="collection_type"
                         value="std::vector&lt;ref_type&gt;">
typedef std::vector&lt;ref_type&gt; collection_type;
                </typedef>

                <typedef name="const_reference"
                         value="detset const&amp;">
typedef detset const&amp; const_reference;
                </typedef>

                <typedef name="const_iterator"
                         value="boost::indirect_iterator&lt;typename collection_type::const_iterator&gt;">
typedef boost::indirect_iterator&lt;typename collection_type::const_iterator&gt; const_iterator;
                    <comment>
      iterator returns a DetSet&lt;T&gt; instead of a Ref&lt;...&gt;
                    </comment>
                </typedef>

                <typedef name="size_type"
                         value="typename collection_type::size_type">
typedef typename collection_type::size_type size_type;
                </typedef>

                <constructor name="DetSetRefVector"
                             return=""
                             args="['void']"
                             vars="['']"
                             qual="">
DetSetRefVector();
                    <comment>
       Add the following only if needed.
      template &lt;class InputIterator&gt;
      DetSetRefVector(InputIterator b, InputIterator e);
                    </comment>
                </constructor>

                <constructor name="DetSetRefVector"
                             return=""
                             args="['const Handle&lt;C&gt;&amp;','const std::vector&lt;det_id_type&gt;&amp;']"
                             vars="['iHandle','iDets']"
                             qual="">
DetSetRefVector(const Handle&lt;C&gt;&amp; iHandle, const std::vector&lt;det_id_type&gt;&amp; iDets);
                </constructor>

                <constructor name="DetSetRefVector"
                             return=""
                             args="['const OrphanHandle&lt;C&gt;&amp;','const std::vector&lt;det_id_type&gt;&amp;']"
                             vars="['iHandle','iDets']"
                             qual="">
DetSetRefVector(const OrphanHandle&lt;C&gt;&amp; iHandle, const std::vector&lt;det_id_type&gt;&amp; iDets);
                </constructor>

                <constructor name="DetSetRefVector"
                             return=""
                             args="['const TestHandle&lt;C&gt;&amp;','const std::vector&lt;det_id_type&gt;&amp;']"
                             vars="['iHandle','iDets']"
                             qual="">
DetSetRefVector(const TestHandle&lt;C&gt;&amp; iHandle, const std::vector&lt;det_id_type&gt;&amp; iDets);
                </constructor>

                <method1 name="swap"
                         return="void"
                         args="['DetSetRefVector&amp;']"
                         vars="['other']"
                         qual="">
void swap(DetSetRefVector&amp; other);
                </method1>

                <operator name="operator="
                          return="DetSetRefVector&amp;"
                          args="['DetSetRefVector const&amp;']"
                          vars="['rhs']"
                          qual="">
DetSetRefVector&amp; operator=(DetSetRefVector const&amp; rhs);
                </operator>

                <method1 name="empty"
                         return="bool"
                         args="['void']"
                         vars="['']"
                         qual="const">
bool empty() const;
                    <comment>
        Return true if we contain no DetSets.
                    </comment>
                </method1>

                <method1 name="size"
                         return="size_type"
                         args="['void']"
                         vars="['']"
                         qual="const">
size_type size() const;
                    <comment>
        Return the number of contained DetSets
                    </comment>
                </method1>

                <method1 name="find"
                         return="const_iterator"
                         args="['det_id_type']"
                         vars="['id']"
                         qual="const">
const_iterator find(det_id_type id) const;
                    <comment>
        if there is no such DetSet.
                    </comment>
                </method1>

                <operator name="operator[]"
                          return="const_reference"
                          args="['det_id_type']"
                          vars="['i']"
                          qual="const">
const_reference operator[](det_id_type i) const;
                    <comment>
        **DO NOT MODIFY THE id DATA MEMBER OF THE REFERENCED DetSet!**
                    </comment>
                </operator>

                <method1 name="begin"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator begin() const;
                    <comment>
        Return an iterator to the first DetSet.
                    </comment>
                </method1>

                <method1 name="end"
                         return="const_iterator"
                         args="['void']"
                         vars="['']"
                         qual="const">
const_iterator end() const;
                    <comment>
        Return the off-the-end iterator.
                    </comment>
                </method1>

            </section>

            <typemap name="collection_type"
                     value="std::vector&lt;Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt; &gt;"
                     type="typedef"/>
            <typemap name="const_iterator"
                     value="typename boost::indirect_iterator&lt;typename std::vector&lt;Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt; &gt;::const_iterator&gt;"
                     type="typedef"/>
            <typemap name="const_reference"
                     value="DetSet&lt;T&gt; const&amp;"
                     type="typedef"/>
            <typemap name="detset"
                     value="DetSet&lt;T&gt;"
                     type="typedef"/>
            <typemap name="ref_type"
                     value="Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt;"
                     type="typedef"/>
            <typemap name="size_type"
                     value="typename std::vector&lt;Ref&lt;C, DetSet&lt;T&gt;, refhelper::FindDetSetForDetSetVector&lt;T, C&gt; &gt; &gt;::size_type"
                     type="typedef"/>
            <typemap name="value_type"
                     value="DetSet&lt;T&gt;"
                     type="typedef"/>

        </class>

        <namespace name="refhelper">
            <comment>
  specialize behavior of edm::Ref to get access to the 'Det'
            </comment>

            <class name="FindForDetSetRefVector"
                   fullname="edm::refhelper::FindForDetSetRefVector&lt;T, C&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="template struct"
                   template="template&lt;typename T, typename C&gt;">
                <baseclass name="public std::binary_function&lt;const DetSetRefVector&lt;T, C&gt;&amp;, std::pair&lt;det_id_type, typename DetSet&lt;T&gt;::collection_type::size_type&gt;, const T*&gt;"/>

                <section>
                    <typedef name="self"
                             value="FindForDetSetRefVector&lt;T, C&gt;">
typedef FindForDetSetRefVector&lt;T, C&gt; self;
                    </typedef>

                    <operator name="operator()"
                              return="typename self::result_type"
                              args="['typename self::first_argument_type','typename self::second_argument_type']"
                              vars="['iContainer','iIndex']"
                              qual="">
typename self::result_type operatorPP(typename self::first_argument_type iContainer, typename self::second_argument_type iIndex);
                    </operator>

                </section>

                <typemap name="self"
                         value="FindForDetSetRefVector&lt;T, C&gt;"
                         type="typedef"/>

            </class>

            <class name="FindTrait&lt;DetSetRefVector&lt;T,C&gt;,T&gt;"
                   fullname="edm::refhelper::FindTrait&lt;DetSetRefVector&lt;T,C&gt;,T&gt;"
                   module="DataFormats.Common"
                   project=""
                   type="specialized template struct"
                   template="template&lt;typename T, typename C&gt;">

                <section>
                    <typedef name="value"
                             value="FindForDetSetRefVector&lt;T, C&gt;">
typedef FindForDetSetRefVector&lt;T, C&gt; value;
                    </typedef>

                </section>

                <typemap name="value"
                         value="FindForDetSetRefVector&lt;T, C&gt;"
                         type="typedef"/>

            </class>
        </namespace>
    </namespace>

    <type name="DetSetRefVector const&amp;"/>
    <type name="DetSetRefVector&amp;"/>
    <type name="LessThanComparableConcept"/>
    <type name="bool"/>
    <type name="boost"/>
    <type name="const Handle&lt;C&gt;&amp;"/>
    <type name="const OrphanHandle&lt;C&gt;&amp;"/>
    <type name="const TestHandle&lt;C&gt;&amp;"/>
    <type name="const ref_type&amp;"/>
    <type name="const std::vector&lt;det_id_type&gt;&amp;"/>
    <type name="const_iterator"/>
    <type name="const_reference"/>
    <type name="det_id_type"/>
    <type name="edm::CompareRefDetSet&lt;T, C&gt;"/>
    <type name="edm::DetSetRefVector&lt;T, C&gt;"/>
    <type name="edm::refhelper::FindDetSetForDetSetVector&lt;T, C&gt;"/>
    <type name="edm::refhelper::FindForDetSetRefVector&lt;T, C&gt;"/>
    <type name="edm::refhelper::FindTrait&lt;DetSetRefVector&lt;T, C&gt;, T&gt;"/>
    <type name="size_type"/>
    <type name="std::binary_function&lt;const C&amp;, edm::det_id_type, const DetSet&lt;T&gt;*&gt;"/>
    <type name="std::binary_function&lt;const DetSetRefVector&lt;T, C&gt;&amp;, std::pair&lt;det_id_type, typename DetSet&lt;T&gt;::collection_type::size_type&gt;, const T*&gt;"/>
    <type name="typename self::first_argument_type"/>
    <type name="typename self::result_type"/>
    <type name="typename self::second_argument_type"/>
    <type name="void"/>
</header>
