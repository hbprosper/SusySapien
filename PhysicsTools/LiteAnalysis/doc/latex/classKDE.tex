\hypertarget{classKDE}{
\section{KDE Class Reference}
\label{classKDE}\index{KDE@{KDE}}
}
{\tt \#include $<$KDE.hpp$>$}



\subsection{Detailed Description}
Model a Kernel Density Estimate (KDE) of a multivariate density. 

{\bf Introduction} 

Kernel density estimation (KDE) is a general non-parametric method to estimate D-dimensional probability densities. The basic idea is to place a kernel function (typically, a diagonal D-dimensional Gaussian) at each of $N$ points sampled from the density to be estimated. In the simplest method, the kernel function located at each point has exactly the same shape. This is the method implemented in the KDE class. 

The KDE is given by

\[ f(X) = (1/N) \sum_{i=1}^N K(X,Y_i), \]

where $K(X,Y)$ is the kernel function, $Y_i$ is the ith point in the D-dimensional space and $X$ is the point at which an estimate of the density is needed. To see why this works, consider what happens if we arrange for $K(X,Y)$ to get narrower as $N$ goes to infinity. In this limit, $K(X,Y)$ becomes $\delta(X-Y)$ and we can write the equation as

\[ f(X) = \int K(X,Y) p(Y) dY = \int \delta(X-Y) p(Y) dY = p(X). \]

The KDE recovers the true density as more and more points are used in the sum in Eq.(1).

{\bf KDE Class}

The KDE class uses the kernel \[ K(X,Y) = \prod_j^D \mbox{Gaussian}(x_j, y_j, h_j), \] where \[ X = (x_1,...x_D, \;\;\; Y = (y_1,...y_D), \] and \[ \mbox{Gaussian}(x, y, h) = \exp(-(x-y)^2/2 h^2)/h\sqrt(2 \pi). \] The parameter $h$ is called the bandwidth, of which there are $D$, one for each dimension. The bandwidths are free parameters that must be chosen appropriately. Choosing them well is critically important to the performance of a KDE. If the bandwidths are too small, the KDE will be very noisy; if they are too large, the KDE will be too smooth. In the KDE class, some default values for these bandwidths are used (see the \hyperlink{classKDE_a7}{optimize()} method). However, better choices for these parameters can be arrived at using the \hyperlink{classKDE_a7}{optimize()} method, which fits 1-D projections of the KDE to the 1-D projections of the data, that is, 1-D histograms, one for each dimension (see the \hyperlink{classKDE_a7}{optimize()} method for details). 

For each histogram, the optimize method computes the chi-squared between this histogram and another computed using the current KDE estimate. The bandwidths are adjusted so as to minimize a simple function of the chi-squared/degree-of-freedom ($\chi^2/ND$), averaged over the n 1-D histograms. The KDE class minimizes the function \[ g(h) = (1-E[\chi^2/ND])^2. \] The motivation for this choice is that a good fit - one that neither over-fits nor under-fits - should yield a $E[\chi^2/ND] = 1$. \begin{Desc}
\item[Examples: ]\par


\hyperlink{build_8C-example}{build.C}.\end{Desc}


\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hyperlink{classKDE_a0}{KDE} ()
\item 
\hyperlink{classKDE_a1}{KDE} (std::string vars)
\begin{CompactList}\small\item\em Create a KDE object. \item\end{CompactList}\item 
virtual \hyperlink{classKDE_a2}{$\sim$KDE} ()
\item 
bool \hyperlink{classKDE_a3}{good} ()
\begin{CompactList}\small\item\em Return true if most recent operation was successful. \item\end{CompactList}\item 
void \hyperlink{classKDE_a4}{add} (std::vector$<$ double $>$ \&d)
\begin{CompactList}\small\item\em Add a point to KDE. \item\end{CompactList}\item 
void \hyperlink{classKDE_a5}{add} (TH1F $\ast$hist)
\begin{CompactList}\small\item\em Add a 1-D histogram to the KDE for use by its \hyperlink{classKDE_a7}{optimize()} method. \item\end{CompactList}\item 
double \hyperlink{classKDE_a6}{normalize} ()
\begin{CompactList}\small\item\em Normalize density within current domain. \item\end{CompactList}\item 
int \hyperlink{classKDE_a7}{optimize} (double scale=200, int maxiter=1000)
\begin{CompactList}\small\item\em Optimize bandwidths, $h$. \item\end{CompactList}\item 
double \hyperlink{classKDE_a8}{density} (std::vector$<$ double $>$ \&x)
\begin{CompactList}\small\item\em Compute density at specified point. \item\end{CompactList}\item 
double \hyperlink{classKDE_a9}{density} (double x, std::string var)
\begin{CompactList}\small\item\em Compute 1-D marginal density at specified point. \item\end{CompactList}\item 
double \hyperlink{classKDE_a10}{operator()} (std::vector$<$ double $>$ \&x)
\begin{CompactList}\small\item\em Compute density at specified point. \item\end{CompactList}\item 
double \hyperlink{classKDE_a11}{operator()} (double x, std::string var)
\begin{CompactList}\small\item\em Compute 1-D marginal density at specified point. \item\end{CompactList}\item 
std::vector$<$ double $>$ \hyperlink{classKDE_a12}{bandwidth} ()
\begin{CompactList}\small\item\em Return bandwidths. \item\end{CompactList}\item 
double \hyperlink{classKDE_a13}{integral} (std::vector$<$ double $>$ \&a, std::vector$<$ double $>$ \&b)
\begin{CompactList}\small\item\em Return integral of density over specified hyper-rectangular domain. \item\end{CompactList}\item 
double \hyperlink{classKDE_a14}{chisq} (int index)
\begin{CompactList}\small\item\em Return $\chi^2/ND$. \item\end{CompactList}\item 
double \hyperlink{classKDE_a15}{chisq} (std::string hname)
\begin{CompactList}\small\item\em Return $\chi^2/ND$ given name of dimension. \item\end{CompactList}\item 
void \hyperlink{classKDE_a16}{write} (std::string name)
\begin{CompactList}\small\item\em Create a self-contained C++ function that computes density. \item\end{CompactList}\item 
void \hyperlink{classKDE_a17}{setvars} (std::vector$<$ std::string $>$ \&vars)
\begin{CompactList}\small\item\em Set variable names. \item\end{CompactList}\item 
void \hyperlink{classKDE_a18}{setlower} (std::vector$<$ double $>$ \&x)
\begin{CompactList}\small\item\em Set lower bounds of domain. \item\end{CompactList}\item 
void \hyperlink{classKDE_a19}{setupper} (std::vector$<$ double $>$ \&x)
\begin{CompactList}\small\item\em Set lower bounds of domain. \item\end{CompactList}\item 
void \hyperlink{classKDE_a20}{setbandwidth} (std::vector$<$ double $>$ \&bandw)
\begin{CompactList}\small\item\em Set bandwidths. \item\end{CompactList}\end{CompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classKDE_a0}{
\index{KDE@{KDE}!KDE@{KDE}}
\index{KDE@{KDE}!KDE@{KDE}}
\subsubsection[KDE]{\setlength{\rightskip}{0pt plus 5cm}KDE::KDE ()}}
\label{classKDE_a0}


\hypertarget{classKDE_a1}{
\index{KDE@{KDE}!KDE@{KDE}}
\index{KDE@{KDE}!KDE@{KDE}}
\subsubsection[KDE]{\setlength{\rightskip}{0pt plus 5cm}KDE::KDE (std::string {\em vars})}}
\label{classKDE_a1}


Create a KDE object. 

Provide a string containing a list of space delimited variable names, one for each dimension. 

Example: 

\footnotesize\begin{verbatim}      KDE kde("pt eta phi");
\end{verbatim}
\normalsize
\hypertarget{classKDE_a2}{
\index{KDE@{KDE}!~KDE@{$\sim$KDE}}
\index{~KDE@{$\sim$KDE}!KDE@{KDE}}
\subsubsection[$\sim$KDE]{\setlength{\rightskip}{0pt plus 5cm}virtual KDE::$\sim$\hyperlink{classKDE}{KDE} ()\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{classKDE_a2}




\subsection{Member Function Documentation}
\hypertarget{classKDE_a5}{
\index{KDE@{KDE}!add@{add}}
\index{add@{add}!KDE@{KDE}}
\subsubsection[add]{\setlength{\rightskip}{0pt plus 5cm}void KDE::add (TH1F $\ast$ {\em hist})}}
\label{classKDE_a5}


Add a 1-D histogram to the KDE for use by its \hyperlink{classKDE_a7}{optimize()} method. 

Add a histogram for each dimension making sure that the histogram name matches that of the associated dimension. 

Example:\par
 If the dimension name is $pt$, then the associated histogram must have the same name. You must add as many names as there are dimensions. \hypertarget{classKDE_a4}{
\index{KDE@{KDE}!add@{add}}
\index{add@{add}!KDE@{KDE}}
\subsubsection[add]{\setlength{\rightskip}{0pt plus 5cm}void KDE::add (std::vector$<$ double $>$ \& {\em d})}}
\label{classKDE_a4}


Add a point to KDE. 

\hypertarget{classKDE_a12}{
\index{KDE@{KDE}!bandwidth@{bandwidth}}
\index{bandwidth@{bandwidth}!KDE@{KDE}}
\subsubsection[bandwidth]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<$double$>$ KDE::bandwidth ()\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classKDE_a12}


Return bandwidths. 

\begin{Desc}
\item[Returns:]vector of bandwidth parameters \end{Desc}
\hypertarget{classKDE_a15}{
\index{KDE@{KDE}!chisq@{chisq}}
\index{chisq@{chisq}!KDE@{KDE}}
\subsubsection[chisq]{\setlength{\rightskip}{0pt plus 5cm}double KDE::chisq (std::string {\em hname})}}
\label{classKDE_a15}


Return $\chi^2/ND$ given name of dimension. 

Example: 

\footnotesize\begin{verbatim}      KDE kde("pt eta phi");
      : :
      kde.add(hpt);  // Add pt histogram
      double y = kde.chisq("pt");
\end{verbatim}
\normalsize
\hypertarget{classKDE_a14}{
\index{KDE@{KDE}!chisq@{chisq}}
\index{chisq@{chisq}!KDE@{KDE}}
\subsubsection[chisq]{\setlength{\rightskip}{0pt plus 5cm}double KDE::chisq (int {\em index})}}
\label{classKDE_a14}


Return $\chi^2/ND$. 

\hypertarget{classKDE_a9}{
\index{KDE@{KDE}!density@{density}}
\index{density@{density}!KDE@{KDE}}
\subsubsection[density]{\setlength{\rightskip}{0pt plus 5cm}double KDE::density (double {\em x}, std::string {\em var})}}
\label{classKDE_a9}


Compute 1-D marginal density at specified point. 

\hypertarget{classKDE_a8}{
\index{KDE@{KDE}!density@{density}}
\index{density@{density}!KDE@{KDE}}
\subsubsection[density]{\setlength{\rightskip}{0pt plus 5cm}double KDE::density (std::vector$<$ double $>$ \& {\em x})}}
\label{classKDE_a8}


Compute density at specified point. 

\hypertarget{classKDE_a3}{
\index{KDE@{KDE}!good@{good}}
\index{good@{good}!KDE@{KDE}}
\subsubsection[good]{\setlength{\rightskip}{0pt plus 5cm}bool KDE::good ()}}
\label{classKDE_a3}


Return true if most recent operation was successful. 

\hypertarget{classKDE_a13}{
\index{KDE@{KDE}!integral@{integral}}
\index{integral@{integral}!KDE@{KDE}}
\subsubsection[integral]{\setlength{\rightskip}{0pt plus 5cm}double KDE::integral (std::vector$<$ double $>$ \& {\em a}, std::vector$<$ double $>$ \& {\em b})}}
\label{classKDE_a13}


Return integral of density over specified hyper-rectangular domain. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em a}]lower bounds of domain \item[{\em b}]upper bounds of domain \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the value of the integral \end{Desc}
\hypertarget{classKDE_a6}{
\index{KDE@{KDE}!normalize@{normalize}}
\index{normalize@{normalize}!KDE@{KDE}}
\subsubsection[normalize]{\setlength{\rightskip}{0pt plus 5cm}double KDE::normalize ()}}
\label{classKDE_a6}


Normalize density within current domain. 

The domain boundaries can be set using the \hyperlink{classKDE_a18}{setlower()} and \hyperlink{classKDE_a19}{setupper()} methods. By default, the boundaries are determined by the outermost points added to the KDE using the \hyperlink{classKDE_a4}{add()} method. \hypertarget{classKDE_a11}{
\index{KDE@{KDE}!operator()@{operator()}}
\index{operator()@{operator()}!KDE@{KDE}}
\subsubsection[operator()]{\setlength{\rightskip}{0pt plus 5cm}double KDE::operator() (double {\em x}, std::string {\em var})}}
\label{classKDE_a11}


Compute 1-D marginal density at specified point. 

\hypertarget{classKDE_a10}{
\index{KDE@{KDE}!operator()@{operator()}}
\index{operator()@{operator()}!KDE@{KDE}}
\subsubsection[operator()]{\setlength{\rightskip}{0pt plus 5cm}double KDE::operator() (std::vector$<$ double $>$ \& {\em x})}}
\label{classKDE_a10}


Compute density at specified point. 

\hypertarget{classKDE_a7}{
\index{KDE@{KDE}!optimize@{optimize}}
\index{optimize@{optimize}!KDE@{KDE}}
\subsubsection[optimize]{\setlength{\rightskip}{0pt plus 5cm}int KDE::optimize (double {\em scale} = {\tt 200}, int {\em maxiter} = {\tt 1000})}}
\label{classKDE_a7}


Optimize bandwidths, $h$. 

For each 1-D histogram (one per dimension) passed to the KDE object using the \hyperlink{classKDE_a4}{add()} method, compute the 1-D histogram formed by projecting the KDE onto the associated axis. Then compute $z = \chi^2/ND$ between the two histograms. $ND$, the number of degrees of freedom, is assumed to be the number of bins (with count greater than 5) minus the number of free parameters, here the number of dimensions. Minuit is used to minimize the function

\[ F(h) = (1 - E[z])^2, \]

with respect to the bandwidths, where $E[z]$ is the average of the $n$ $\chi^2/ND$ values.

Each bandwidth is searched is in the domain $[0,scale \times h]$, where $h$ is the default bandwidth, computed using the expression

\[ h = \sigma \left[\frac{4}{(D+2)N}\right]^{1/(D+4)}, \]

where $\sigma$ is the standard deviation of the associated 1-D density, $D$ is the dimensionality of the data, and $N$ is the number of points in the KDE. This expression is a good approximation to the optimal bandwidth for a Gaussian, but it may be far from optimal for non-Gaussian distributions. \hypertarget{classKDE_a20}{
\index{KDE@{KDE}!setbandwidth@{setbandwidth}}
\index{setbandwidth@{setbandwidth}!KDE@{KDE}}
\subsubsection[setbandwidth]{\setlength{\rightskip}{0pt plus 5cm}void KDE::setbandwidth (std::vector$<$ double $>$ \& {\em bandw})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classKDE_a20}


Set bandwidths. 

\hypertarget{classKDE_a18}{
\index{KDE@{KDE}!setlower@{setlower}}
\index{setlower@{setlower}!KDE@{KDE}}
\subsubsection[setlower]{\setlength{\rightskip}{0pt plus 5cm}void KDE::setlower (std::vector$<$ double $>$ \& {\em x})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classKDE_a18}


Set lower bounds of domain. 

\hypertarget{classKDE_a19}{
\index{KDE@{KDE}!setupper@{setupper}}
\index{setupper@{setupper}!KDE@{KDE}}
\subsubsection[setupper]{\setlength{\rightskip}{0pt plus 5cm}void KDE::setupper (std::vector$<$ double $>$ \& {\em x})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classKDE_a19}


Set lower bounds of domain. 

\hypertarget{classKDE_a17}{
\index{KDE@{KDE}!setvars@{setvars}}
\index{setvars@{setvars}!KDE@{KDE}}
\subsubsection[setvars]{\setlength{\rightskip}{0pt plus 5cm}void KDE::setvars (std::vector$<$ std::string $>$ \& {\em vars})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{classKDE_a17}


Set variable names. 

\hypertarget{classKDE_a16}{
\index{KDE@{KDE}!write@{write}}
\index{write@{write}!KDE@{KDE}}
\subsubsection[write]{\setlength{\rightskip}{0pt plus 5cm}void KDE::write (std::string {\em name})}}
\label{classKDE_a16}


Create a self-contained C++ function that computes density. 



The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
/home/harry/CMS/cmssw/CMSSW\_\-3\_\-2\_\-5/src/Physics\-Tools/Lite\-Analysis/interface/\hyperlink{KDE_8hpp}{KDE.hpp}\end{CompactItemize}
